# Паттерн Abstract Factory

## Введение

Давайте рассмотрим ситуацию, в которой нам нужно наладить производство мебели: стулья, диваны, столы и т.д.

При этом мебель производится для разных стилей интерьера: модерн, ампир, лофт и т.д.

Просто создавать каждый раз объекты в необходимых местах через конструктор или формирование объекта с помощью сеттеров проблематично.

В каждой точке программы нужно будет прописывать конструкции вида:

```java
new Chair("modern").setMaterial("wood") ....
new Table("modern").setMaterial("wood") ....
new Sofa("modern").setMaterial("wood") ....
```

При этом, важно понимать, что вам нужна мебель, то она нужна для одного интерьера, т.е. вам нужен единый стиль мебели. Ситуация в которой клиент по ошибке получит стул стиля модерн, другой стул лофт, а диван ампир - это нехорошая ситуация.

Или представьте, что вы пишите игру и вам надо создать армию из эльфов, окров и нежити.
И вот вы создаете эльфов и тут вдруг, как и со стульями, опечатались/ошиблись и у вас в армии эльфов вдруг орк или нежить.

Т.е. наша проблема - это создание различных групп взаимосвязанных объектов.
Нам нужен спо­соб созда­вать объ­ек­ты (юниты в армиях, стулья, столы и т.д.), чтобы они соче­та­лись с дру­ги­ми объектами (юнитами, диванами, стульями) того же семей­ства.

Крайне важно в нашем решении проблемы будет не потерять гибкость, чтобы при необходимости переход на, например, другой стиль мебели не требовал переписывания большого количества кода.

## Абстрактная фабрика

Давайте выделим общие интерфейсы, составляющих семейства объектов:

```java
// стулья
public interface Chair {}

public class ModernChair implements Chair {}

public class LoftChair implements Chair {}

// диваны
public interface Sofa {}

public class ModernSofa implements Sofa {}

public class LoftSofa implements Sofa {}
```

Раз у нас несколько семейств, то и фабрик будет несколько: на каждое семейство своя фабрика, по своей специализации.

```java
class ModernFurnitureFactory {
    // реализация
}

class LoftFurnitureFactory {
    // реализация
}
```

Однако все наши фабрики хоть и работают в определнном стиле, но выпускают мебель.

Таким образом, мы можем выделить некоторую 'абстрактную' фабрику, предоставляющую общий интерфейс создания имеющихся продуктов (объектов семейства). А реализации этой абстрактной фабрики уже будут отвечать за создание продуктов своего семейства.

Получаем иерархию:

```java
public interface FurnitureFactory {
    Chair createChair();
    Sofa createSofa();
}

class ModernFurnitureFactory implements FurnitureFactory {
    // реализация
}

class LoftFurnitureFactory implements FurnitureFactory {
    // реализация
}
```

Клиенту мы просто передаем ссылку на абстрактную фабрику:

```java
public class Client {
    private FurnitureFactory factory;

    public Client(FurnitureFactory factory) {
        this.factory = factory;
    }

    public void furniture() {
        factory.createChair();
        factory.createSofa();
    }
}
```

Теперь клиент, работая с абстрактной фабрикой, получает то что хочет: мебель. При этом, у нас есть гарантия того, что все объекты одного будут одного семейства. Хотим использовать стиль модерн - клиенту передаем ссылку на реализацию ModernFurnitureFactory.

А благодаря тому, что у клиента абстракция фабрики, то при необходимости изменить интерьер - ему нужно будет только передат другую фабрику, не меняя клиентский код.

Если на пальцах, то все очень приближенно к тому, как все происходит в жизни: вы, как клиент, хотите приобрести мебель в определнном стиле, для этого вам нужен телефон (по сути - ссылка на реализацию) мебельной фабрики, которая производит мебель этого стиля! Решили сменить интерьер - поменяли ссылку (взяли другой телефон) на новую фабрику!

## Разница с Factory Method

Те, кто только начинает знакомство с этим паттерном, обычно пребывают в недоумении, так как это очень напоминает [Factory Method](./factory_method.md).

На самом деле, абстрактная фабрика основывается на фабричном методе.

Основное назначение паттерна - это предоставить интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, без акцента на конкретных реализациях.

Т.е. абстрактная фабрика - это по сути работа с семейством фабричных методов.

## Применимость

Паттерн часто можно встретить во всяких фреймворках, которые предполагают гибкую настройку через конфигурацию или переменные окружения, например, `Spring`.

Также применяется в кроссплатформенных фреймворках и библиотеках. Когда на старте приложения вы создаете фабрики, производяющие объекты под ту или иную платформу.

Например, в зависимости от операционной системы вы можете создать фабрики, создающие графические элементы: кнопки, лейблы, чекбоксы и т.д. На старте приложения создаются фабрики под конкретную операционную систему (например, macOS) и отдаются клиентскому коду. При этом клиентский код работает с абстракцией, поэтому если он будет запущен на другой операционной системе (например, Windows) сам код не будет изменен, просто будет передана реализация, делающая кнопки и чекбоксы под Windows.

![abstract factory](../../images/patterns/abstract_factory/abstract_factory_example.png)

## Заключение

Широко применимый паттерн, отвечающий за создание различных групп взаимосвязанных объектов и позволяющий гибко работать с кодом клиента.

Клиентский код работает c абстракциями, а производством конкретных объектов занимаются реализации фабрик. Благодаря группировке по семействам объектов паттерн гарантирует сочетаемость производимых объектов.

## Полезные ссылки

1. [Абстрактная фабрика на пальцах](https://habr.com/ru/post/465835/)
2. [Шаблоны Java. AbstractFactory (Абcтрактная фабрика)](https://www.youtube.com/watch?v=cmyUI_ZezoU)
3. [Шаблоны Java. Абстрактная фабрика (Abstract Factory)](https://www.youtube.com/watch?v=FYX9l5OQtJE)
4. [Абстрактная Фабрика](https://www.youtube.com/watch?v=1mVONOCxfLg)
