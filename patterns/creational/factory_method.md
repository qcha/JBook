# Паттерн Factory Method

## Введение

Давайте рассмотрим ситуацию, в которой вы пишите код для поощрения игроков вашей игры.
Вы вводите сущность `Подарок` и оперируете ей, создавая и даря подарки-монетки игрокам.

Выглядит это в виде:

```java
if (пользователь заслужил подарок) {
    return new Coin(...);
} 
```

И таких мест, где вы решаете дарить или не дарить пользователю что-то по всей вашей игре большое количество.

В этот момент вы уже чувствуете желание, что было бы неплохо вынести куда-то этот повторяемый код по созданию ваших монеток. Потому что параметров для создания монетки-подарка может быть много, запутаться в них просто, да и копипаста кода - это нехорошо.

Спустя какое-то время вы понимаете, что варианты подарков могут быть разные и хотите ввести в свою очередь новую сущность, платиновую монетку: `PlatinumCoin`. И по каким-то условиям, например, в 10% случаях дарить вместо обычной, платиновую монетку!

И теперь мы с вами сталкиваемся с новой проблемой: теперь нам надо **во всех** местах, где вы дарили подарки, добавить еще поддержку этой сущности.

При этом мы понимаем, что все это разные реализации одной сущности: `Подарка`.

В таком случае, мы можем определить интерфейс (или абстрактный класс) для создания подарка, а реализациям интерфейса делегировать решение о том, какой **конекретно** подарок создавать. Фабричный метод позволяет классу делегировать инстанцирование подклассам.

## Фабричный Метод

Выделим сущность подарка:

```java
interface Gift {
    int cost();
}
```

> На самом деле это может быть и обычный, и абстрактный класс.
> Важно именно выделить абстракцию.

Добавим реализации подарков, наши монетки:

```java
public class Coin implements Gift {

    // конструктор создания объекта монеты
    public Coin(...) {
        // логика
    }

    @Override
    public int cost() {
        return 100;
    }
}

public class PlatinumCoin implements Gift {

    // конструктор создания объекта платиновой монеты
    public PlatinumCoin(...) {
        // логика
    }

    @Override
    public int cost() {
        return 10_000;
    }
}
```

Процесс создания монет может быть разным, поэтому определим интерфейс для создания подарка, а реализациям интерфейса будем делегировать решение о том, какой **конкретно** подарок создавать:

```java
public interface GiftGenerator {
    default int openGift() {
        // ... что-то про логику открытия подарка ...
        Gift gift = createGift();
        return gift.cost();
    }

    /**
     * Реализации интерфейса будут сами решать как создавать подарок, 
     * переопределяя этот метод.
     */
    Gift createGift();
}
```

По сути `createGift` - это и есть наш `фабричный метод`.

После чего под каждый подарок делаем свой генератор:

```java
public class CoinGenerator implements GiftGenerator {
    @Override
    public GameItem createItem() {
        return new Coin(...);
    }
}

public class PlatinumCoinGenerator implements GiftGenerator {
    @Override
    public GameItem createItem() {
        return new PlatinumCoin(...);
    }
}
```

Теперь просто добавим наши генераторы в место, где мы раздаем подарки!

```java
List<GiftGenerator> generators = new ArrayList<>();
generators.add(new CoinGenerator());
generators.add(new PlatinumCoinGenerator());

// ... код программы ...
if (дарим_подарок_рандомно) {
    generators.get(ThreadLocalRandom.current().nextInt(2)).openGift();
}
```

Какие проблемы мы решили?

Выделив абстракцию подарка, фабричный метод для создания (это наши генераторы), мы получили:

1. Возможность гибко добавлять новые подарки, по сути просто создав необходимые генераторы, переопределяющие фабричный метод создания подарка.

2. Контроль над созданием подарков. Каждый генератор может по своему создавать подарок, за который ответственен.

## Общий вид паттерна

Теперь давайте для закрепления разберем из чего состоит и нарисуем как выглядит паттерн в общем виде.

Составляющие:

1. Product
    Определяет интерфейс объектов, создаваемых абстрактным методом.

    В нашем примере: подарок, `Gift`.

2. ConcreteProduct
    Конкретная реализация продукта, реализующая интерфейс Продукта.

    В нашем примере: `Coin` и `PlatinumCoin`.

3. Creator
    Объявляет фабричный метод, который возвращает объект Продукта. Здесь может быть и реализация фабричного метода по умолчанию.

    В нашем примере: генератор подарков, `GiftGenerator`.
    Фабричный метод в нашем примере: `Gift createGift()`.

4. ConcreteCreator
    Реализация класса, создающего конкретные реализации продуктов.

    В нашем примере: генератор монеток `CoinGenerator` и генератор платиновых монеток `PlatinumCoinGenerator`.

Важно понимать, что `Creator` не обязательно состоит **только** из одного фабричного метода. Он вполне может содержать и другой полезный код по работе с `Product`.

`Creator` может также определять реализацию по умолчанию фабричного метода, который возвращает объект `ConcreteProduct`.
Он может вызывать фабричный метод для создания объекта `Product`, как это сделано в нашем примере с генераторами и подарками.

Схематично паттерн выглядит следующим образом:

![factory method](../../images/patterns/factory_method/factory_method_pattern.png)

## Применение

Встретить можно, например, если вы работаете с базой данных и вам нужны `connection`-ы к ней. Для различных БД соединения могут создаваться по разному, но в итоге мы хотим получить именно соединение с БД.

Настройки же для соединения вы, например, указываете в конфигурационном файле при старте.

Создаем интерфейс соединения (`Product`), выделяем интерфейс задача которого эти самые соединения создавать (`Creator`), пишем под каждую БД реализации интерфейсов, а дальше при старте берете необходимую реализацию под свою базу данных!

Собственно, это и сделано в `javax.sql.Connection` и `javax.sql.DataSource`.

## Заключение

Паттерн предоставляет возможность выделить код создания объектов, относительную простоту добавления новых продуктов и работы с ними.

Этот паттерн позволяет вам использовать `open/closed`-принцип ([O из SOLID](../../oop/SOLID.md)), благодаря работе с интерфесами и добавлению новых `Creator`-ов.

## Полезные ссылки

1. [Фабричный метод (шаблон проектирования)](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))
2. [Java. Factory Method Pattern in Game Server](https://habr.com/ru/post/571502/)
3. [Volodya Mozhenkov Фабричный метод](https://www.youtube.com/watch?v=5UqUDR6_2cY)
