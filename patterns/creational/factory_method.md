# Паттерн Factory Method

## Введение

Давайте рассмотрим ситуацию, в которой вы пишите код для поощрения игроков в игре.
Вы вводите сущность `Подарок` и оперируете ей, создавая и даря подарки-монетки игрокам.

Выглядит это в виде:

```java
if (пользователь заслужил подарок) {
    return new Coin(...);
} 
```

И таких мест, где вы решаете дарить или не дарить пользователю что-то, по всей вашей игре огромное количество.

Спустя какое-то время вы понимаете, что варианты подарков могут быть разные и хотите ввести в свою очередь новую сущность, платиновую монетку: `PlatinumCoin`. И по каким-то условиям, например, в 10% случаях дарить вместо обычной, платиновую монетку!

И теперь мы с вами сталкиваемся с проблемой: теперь надо **во всех** местах, где был код по дарению монеток, добавить еще поддержку новой сущности.

При этом мы понимаем, что все это разные реализации одной сущности: `Подарок`. Просто **реализации** подарков разные.

Т.е. основная проблема в том, что под каждую новую реализацию наш код приходится постоянно менять, при этом изменения размазаны по кодовой базе.

Параметров для создания монеток-подарков тоже может быть много, да и повторяемости кода с постоянным созданием монеток хочется избежать.

В таком случае, можно определить интерфейс (или абстрактный класс) для создания подарка, а реализациям интерфейса () делегировать решение о том, какой **конкретно** подарок создавать. Фабричный метод позволяет классу делегировать инстанцирование подклассам.

## Фабричный Метод

Выделим сущность подарка (на самом деле это может быть как обычный, так и абстрактный класс, но здесь сделаем через интерфейс):

```java
interface Gift {
    int cost();
}
```

Добавим реализации подарков, наши монетки:

```java
public class Coin implements Gift {

    // конструктор создания объекта простой монетки
    public Coin(...) {
        // логика
    }

    @Override
    public int cost() {
        return 100;
    }
}

public class PlatinumCoin implements Gift {

    // конструктор создания объекта платиновой монеки
    public PlatinumCoin(...) {
        // логика
    }

    @Override
    public int cost() {
        return 10_000;
    }
}
```

Определим интерфейс для создания подарка:

```java
public interface GiftGenerator {
    default int openGift() {
        // ... что-то про логику открытия подарка ...
        Gift gift = createGift();
        return gift.cost();
    }

    /**
     * Реализации интерфейса будут сами решать как создавать подарок, 
     * переопределяя этот метод.
     */
    Gift createGift();
}
```

При этом реализациям интерфейса будем делегировать решение о том, какой **конкретно** подарок создавать.
По сути `createGift` - это и есть наш `фабричный метод`.

После чего под каждый подарок делаем свой генератор:

```java
public class CoinGenerator implements GiftGenerator {
    @Override
    public GameItem createItem() {
        return new Coin(...);
    }
}

public class PlatinumCoinGenerator implements GiftGenerator {
    @Override
    public GameItem createItem() {
        return new PlatinumCoin(...);
    }
}
```

Добавляем генераторы в место, где раздаем подарки:

```java
// Подготавливем генераторы подарков
List<GiftGenerator> generators = new ArrayList<>();
generators.add(new CoinGenerator());
generators.add(new PlatinumCoinGenerator());

// ... код программы ...
if (дарим_подарок_рандомно) {
    generators.get(ThreadLocalRandom.current().nextInt(2)).openGift();
}
```

Какие проблемы мы решили?

Выделив абстракцию подарка, фабричный метод для создания (это наши генераторы), мы получили:

1. Возможность гибко добавлять новые подарки, по сути просто создав необходимые генераторы, переопределяющие фабричный метод создания подарка.

2. Контроль над созданием подарков. Каждый генератор может по своему создавать подарок, за который ответственен.

## Общий вид паттерна

Теперь давайте для закрепления разберем из чего состоит и нарисуем как выглядит паттерн в общем виде.

Составляющие:

1. Product
    Определяет интерфейс объектов, создаваемых абстрактным методом.

    В нашем примере: подарок, `Gift`.

2. ConcreteProduct
    Конкретная реализация продукта, реализующая интерфейс Продукта.

    В нашем примере: `Coin` и `PlatinumCoin`.

3. Creator
    Объявляет фабричный метод, который возвращает объект Продукта. Здесь может быть и реализация фабричного метода по умолчанию.

    В нашем примере: генератор подарков, `GiftGenerator`.
    Фабричный метод в нашем примере: `Gift createGift()`.

4. ConcreteCreator
    Реализация класса, создающего конкретные реализации продуктов.

    В нашем примере: генератор монеток `CoinGenerator` и генератор платиновых монеток `PlatinumCoinGenerator`.

Важно понимать, что `Creator` не обязательно состоит **только** из одного фабричного метода. Он вполне может содержать и другой полезный код по работе с `Product`.

`Creator` может также определять реализацию по умолчанию фабричного метода, который возвращает объект `ConcreteProduct`.
Он может вызывать фабричный метод для создания объекта `Product`, как это сделано в нашем примере с генераторами и подарками.

Схематично паттерн выглядит следующим образом:

![factory method](../../images/patterns/factory_method/factory_method_pattern.png)

## Применение

Встретить можно, например, если вы работаете с базой данных и вам нужны `connection`-ы к ней. Для различных БД соединения могут создаваться по разному, но в итоге мы хотим получить именно соединение с БД.

Настройки же для соединения вы, например, указываете в конфигурационном файле при старте.

Создаем интерфейс соединения (`Product`), выделяем интерфейс задача которого эти самые соединения создавать (`Creator`), пишем под каждую БД реализации интерфейсов, а дальше при старте берете необходимую реализацию под свою базу данных!

Собственно, это и сделано в `javax.sql.Connection` и `javax.sql.DataSource`.

## Заключение

Паттерн предоставляет возможность выделить код создания объектов, относительную простоту добавления новых продуктов и работы с ними.

Этот паттерн позволяет вам использовать `open/closed`-принцип ([O из SOLID](../../patterns/SOLID.md)), благодаря работе с интерфесами и добавлению новых `Creator`-ов.

## Полезные ссылки

1. [Фабричный метод (шаблон проектирования)](https://ru.wikipedia.org/wiki/%D0%A4%D0%B0%D0%B1%D1%80%D0%B8%D1%87%D0%BD%D1%8B%D0%B9_%D0%BC%D0%B5%D1%82%D0%BE%D0%B4_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F))
2. [Java. Factory Method Pattern in Game Server](https://habr.com/ru/post/571502/)
3. [Volodya Mozhenkov Фабричный метод](https://www.youtube.com/watch?v=5UqUDR6_2cY)
