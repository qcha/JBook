# Общие советы и практики

## Введение

Общие рекомендации по написанию кода и подводных камнях, которые могут быть не столь очевидны на первый взгляд, особенно для начинающих.

## Использование статических методов для создания экземлпяра класса

Если класс предоставляет возможность создания экземпляра через статический метод,
например, `String.valueOf()`, то лучше использовать именно его.

В частности, статические методы создания `valueOf()` у классов-оболочек примитивов,
кроме чисел с плавающей точкой, имеют кеш. По умолчанию данный кеш содержит значения
 от -128 до 127, если значение попадает в кеш - оно достается в 3 раза быстрее,
 чем при использовании конструктора, при этом не расходуется лишняя память.
  Наиболее часто используемые значения также кешируются.

Если ваше приложение очень часто использует целые типы, можно увеличить кеш для Integer через системное свойство `java.lang.Integer.IntegerCache.high`,
 а так же через параметр виртуальной машины `-XX:AutoBoxCacheMax=<size>`.

##### Пример:
 Часто можно встретить такой код:
 ```java
 String first = new String("Hello");
 ```
 И чем же он отличается от:
 ```java
 String first = "Hello";
 ```

А отличается он вот чем - в первом случае мы при каждом проходе через этот код будем создавать *новый* объект String.
Во втором же строка "Hello" поместится в пулл строк, откуда будет браться.

#### Autoboxing
Пусть мы хотим посчитать сумму чисел. Если мы напишем так:
```java
Integer sum = 0;
for(int i = 1; i < 100; i++)
    sum += i;
```
Мы каждый раз при суммировании будем создавать Integer объект-упаковку!
А все потому, что мы sum объявили как Integer!

Используйте примитивы и аккуратнее с `boxing`.
#### Выносите константы из методов
```java
public void method1() {
String host = "host";
int port = 22;
//do work
}
```

Нет смысла держать эти переменные в методе - их надо либо выносить в константы класса или передавать в метод параметрами.

#### String + String
Как уже писал я в [String in Java](./StringJava.md), крайне не рекомендуется использование конкатенации строк в циклах.
```java
String[] elements = {"a", "b"};
String s = "";
for(String elem in elements) {
    s = s + elem;
 }
```
Это снизит производительность, потому что при `s = s + elem` создается StringBuilder на основе s, вызывается у него `append()`, а после - `toString()`.

Т.е мы выполняем 3 операции. При этом при следующей конкатенации произойдет то же самое.
Гораздо лучше будет, если сделать:
```java
StringBuilder s = new StringBuilder();
```
Добавлять туда строки и только *после* цикла конкатенаций делать `toString()`.

При этом надо понимать, что всегда, когда вам **не** нужна синхронизация - использовать надо `StringBuilder`.
В случае же, если вы из нескольких потоков делаете строку(т.е нужна синхронизация) - используйте `StringBuffer`.
Его методы являются синхронизированными(`synchronized`), и в результате `StringBuffer` на порядок медленнее `StringBuilder`.


#### instanceOf
В местах и приложениях, где важно быстродействие, старайтесь свести к минимуму использование оператора `instenceOf`.
 Это довольно таки дорогостояющая операция. Если вы используете его - постарайтесь подумать, как можно избежать его использования.

Разумеется, иногда без него не обойтись, например, при переопроеделинии метода `equals()`.

#### Не используйте interface-ы для описания констант.
Лично я считаю, что использование констант в интерфейсах - не совсем верно. Интерфейс - это все-таки API класса, это его поведение.
Гораздо лучше и ,как по мне, правильней - вынести константы в класс констант.

Как это сделать и использовать - [Classes For Static](../start/classes_for_static.md).

#### Свести использование null к минимуму.
`Null` - это наиболее частый источник проблем.
Поэтому, неплохим выходом в ограничении использования `null` будет работа с пустыми коллекциями.
В некоторых случаях я вижу, что ситуации, когда значений нет интерпретируются как возвращающие `null`.
Вместо этого, в тех задачах, где это возможно - лучше возвращать пустую коллекцию.
Например:
```java
public List<Book> getBooksByAuthor(String authorName) {
  //do some work
  return Collections.emptyList();
}

```
В Java есть следующие неизменяемые коллекции:
```java
Collections.emptyList();
Collections.emptyMap();
Collections.emptySet();
```
Про пустые коллекции я писал [Empty in Collection](../collections/empty_collections.md).

В java8 появился специальный тип для защиты от NPE: `Optional`:
```java
public Optional<Book> getBooksByAuthor(String authorName) {
  //do some work
  return Optional.empty();
}
```
