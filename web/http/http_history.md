// TODO ПЕРЕПИСАТЬ
# История HTTP
https://www.youtube.com/watch?v=a-sBfyiXysI&t=172s

## Введение

Вне зависимости от того каким разработчиком вы являетесь, `frontend` или `backend`, знания `HTTP`-протокола всегда будут актуальными, поскольку сетевая составляющая является неотъемлемой частью современной разработки.

Вспомним, что такое `HTML` - это HyperText Markup Language, "язык гипертекстовой разметки".

Аббревиатура `HTTP` расшифровывается как `HyperText Transfer Protocol`, «протокол передачи гипертекста».
Это протокол, который специально создавался для операциями над гипертекстовыми документами.

`HTTP` — широко распространённый протокол передачи данных, изначально предназначенный для передачи гипертекстовых документов (частный случай - `HTML`), в настоящий момент используется для передачи произвольных данных.

`HTTP` является протоколом прикладного уровня по модели [OSI](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI) (верхнего, 7-го).

![OSI](../images/http/OSI.png)

## Как отправлять запросы

Для отправки запросов нам понадобится консоль.

В этой статье я использовал `nc` для подключения к серверу и отправке `HTTP`-запросов, например:

```sh
nc -vc stallman.org 80
Connection to stallman.org port 80 [tcp/http] succeeded!
```

Мы открываем `TCP`-соединение с stallman.org по 80-порту. После чего можем писать запросы.

Можно также использовать `telnet`, если он у вас есть:

```sh
telnet stallman.org 80
```

## HTTP 0.9

Первая версия спецификации протокола `HTTP 0.9` [появилась в 1991 году](https://www.w3.org/Protocols/HTTP/AsImplemented.html).

Протокол `HTTP 0.9` предполагал использование клиент-серверной структуры передачи данных, т.е. наличие клиента и сервера. Клиентское приложение формирует запрос и отправляет его на сервер, после чего сервер обрабатывает данный запрос, формирует ответ и передаёт его обратно клиенту. После чего клиент может продолжить слать запросы, которые будут обработаны аналогичным образом.

Работа протокола была на основе `TCP`, который использовался как основной транспорт. `TCP`-соединение закрывалось после реагирования на `HTTP`-запрос.
Т.е. на каждый запрос открывалось `TCP`-соединение и после ответа оно закрывалось.

Клиент устанавливал `ТСР-IP` соединение с хостом, используя или его доменное имя, или `IP`-адрес плюс номер порта, указанный в адресе. Если номер порта не был указан, тогда предполагалось, что будет использован 80 порт.

Каждый запрос - это строка, состоящая из слова `GET`, после которого следовал пробел и адрес документа. Строка содержит исключительно `ASCII` символы, без дополнительных заголовков:

```javascript
GET /index.html
```

Окончанием запроса считалась последовательность `\r\n`, перевод строки.

В качестве ответа будет поток байтов в кодировке `ASCII`. И, как уже было сказано выше, после ответа сервер разрывает `TCP`-соединение.

Пользователь делал запрос ресурса (например, как показано выше), в ответ получал страницу, например:

```html
<!DOCTYPE html>
<html>
   <head>
      <title>HTML Links</title>
   </head>

   <body>
      <h1>Reach us here</h1>
      <a href="https://github.com/qcha/JBook">JBook</a>
   </body>
</html>
```

Пользователь мог перейти по ссылке, по сути, сделав снова запрос уже нового ресурса.

Если запрашиваемого ресурса нет, например вы делаете запрос на несуществующую страницу, то по протоколу `HTTP 0.9` предполагался ответ в виде текста в формате `HTML` с описанием ошибки. При этом не было никакого способа отличить ответ об ошибке от положительного ответа (и то, и то были `HTML` странички), кроме содержания текста.

Запросим несуществующую страницу:

```javascript
GET /my_page_not_found.html
```

Ответ:

```html
<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html>
    <head>
        <title>400 Bad Request</title>
    </head>
    <body>
        <h1>Bad Request</h1>
        <p>Your browser sent a request that this server could not understand.<br/></p>
    <hr>
    <address>Apache/2.4.38 (Debian) OpenSSL/1.1.1n Server at stallman.org Port 80</address>
    </body>
</html>
```

С точки зрения использования это было неудобно: отличить ошибку от нормальной работы сложно (надо смотреть ответ, что за `HTML` страничка вернулась), передавать можно только `HTML`, а хотелось бы и другие форматы, вдобавок не всегда по запросу нужно получать весь ресурс, иногда нужно просто получить некоторую метаинформацию о ресурсе.

Растущие требования к протоколу привели к новой версии.

### Минусы

Сложно отличить ошибку от верной работы.

Нет возможности передать вместе с запросом (или получить с ответом) какую-либо метаинформацию.

Взаимодействие только через `GET` - получение гипертекста.

## HTTP 1.0

Спецификация протокола `HTTP 1.0` [появилась в мае 1996 года](https://www.rfc-editor.org/rfc/rfc1945).

Что добавлено в этой версии протокола?

### Заголовки

Были добавлены `Header`-ы или `Заголовки`.

Что такое заголовок?

Заголовок - это строка в `HTTP`-сообщении (запросе или ответе), содержащая не чувствительное к регистру название, а затем после двоеточия непосредственно значение. Пробелы перед значением игнорируются. Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.

Пример запроса с заголовком:

```html
GET /wiki/HTTP HTTP/1.0
User-Agent: google сhrome
```

Обратите внимание на то, что теперь после `GET /wiki/HTTP` (после названия метода и адреса запроса) следует еще и версия протокола, по которой мы хотим общаться с сервером: `HTTP/1.0`.
Это сделано для обратной совместимости.

Заголовки `HTTP` позволяют клиенту и серверу отправлять дополнительную информацию с `HTTP` запросом или ответом.

Что это может быть за дополнительная информация?
Например, что за браузер отправил запрос:

```html
User-Agent: google сhrome
```

Или с каким ресурсом мы работаем:

```html
Content-Type: text/html
```

[Полный перечень заголовков в HTTP 1.0](https://www.rfc-editor.org/rfc/rfc1945#section-10)

Заголовки позволили передавать метаданные, благодаря чему протокол стал более мощным, добавив гибкость и расширяемость.

Заголовки позволили передавать документы, отличные от обычных `HTML`-файлов, за что отвечает заголовок `Content-Type`. Также протокол привнес возможности аутентификации пользователя, сжатия передаваемых данных, кэширование ресурсов и прочие возможности.

### Статус коды

Давайте снова запросим несуществующую страницу:

```javascript
GET /my_page_not_found.html HTTP/1.0
```

Ответ:

```html
HTTP/1.1 400 Bad Request
Date: Sat, 01 Oct 2022 15:11:08 GMT
Server: Apache/2.4.38 (Debian) OpenSSL/1.1.1n
Content-Length: 319
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html><head>
<title>400 Bad Request</title>
</head><body>
<h1>Bad Request</h1>
<p>Your browser sent a request that this server could not understand.<br />
</p>
<hr>
<address>Apache/2.4.38 (Debian) OpenSSL/1.1.1n Server at stallman.org Port 80</address>
</body></html>
```

Как видно выше, в ответах появились [статус коды](https://www.rfc-editor.org/rfc/rfc1945#section-9), которые является частью первой строки ответа сервера.

Т.е. в версии `HTTP 1.0` появилась возможность отличить ошибку от нормальной работы по коду.
Статус коды могли сообщать не только об ошибках в ответе на запрос, но также об успешном ответе как на стороне сервера, так и в запросе клиента, или могли сигнализировать то, что необходимо перенаправить пользователя на другую страницу.

Статус код по отсутствующей странице в нашем примере: `400 Bad Request`.

Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа.

Примеры:

```javascript
201 Webpage Created
403 Access allowed only for registered users
507 Insufficient Storage
```

Про классы состояния поговорим позже, в более актуальной версии `HTTP`-протокола.

### Методы

Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Название чувствительно к регистру.

В версии `HTTP 0.9` был только метод `GET`, указывающий на операцию получения ресурса.

В версии `HTTP 1.0` были добавлены еще `POST` (операцию отправки данных на сервер), `HEAD` (операция получения заголовков) методы.

В особенности большую роль сыграл метод `POST`. Теперь веб-страницы могли использоваться не только для просмотра гипертекста, но и для передачи данных на сервер, которые сервер мог превратить в новое сообщение на доске объявлений, в новость в группе новостей, или сервер мог ответить каким-нибудь блоком данных на отправленную ранее форму запроса.

Метод `HEAD` необходим для получения заголовков (и только их). Ответ на метод `HEAD` не должен содержать тело. Если это не так, то его следует игнорировать.

### Кеширование

Положено начало механизму кеширования.

Механизм кеширования в был устроен просто. Клиент запрашивает ресурс, затем исходный сервер возвращает ресурс вместе со следующими заголовками `HTTP`: `Expires` (дата, после которой 'срок годности' истечет и кеш по этому ресурсу должен быть сброшен/будет признан невалидным) и `Last-Modified` (когда последний раз ресурс был изменен).

Затем клиент может указать исходному серверу отправлять ресурс только в том случае, если у него есть более новая копия, используя заголовок `If-Modified-Since`.

Клиент также мог запросить ресурс так, чтобы он не брался из кеша, используя заголовок `Pragma: no-cache`.

### Минусы

Текущая версия позволяла работать в формате один сайт - один сервер.
Делая запрос мы обращаемся к серверу, создаем `TCP`-соединение и общаемся в рамках него.

Чего бы нам хотелось? Несколько сайтов на одном сервере.

Что бы еще хотелось?
На каждый запрос открывать свое соединение и закрывать его после - это слишком дорого.

![Http 1.0 Connections](../images/http/http1_connection.png)

Необходимо переиспользовать уже открытые соединения. Т.е. не закрывать соединение, а поддерживать его активным, через него отправляя еще какие-то запросы. Такие соединения называют постоянными (`persistent connections`).

Протокол `HTTP/1.0` по умолчанию не поддерживает постоянные соединения.
Клиент должен отправить заголовок `Connection` со значением `keep-alive`, чтобы указать серверу, что соединение должно оставаться открытым для любых последующих запросов. Тем не менее, сервер может закрыть указанное соединение после первого ответа или вообще любого ответа. Никаких гарантий на это нет.

## HTTP 1.1

Спустя год после появления [HTTP 1.0](https://tools.ietf.org/html/rfc1945), в январе 1997 года выходит новая версия протокола [HTTP 1.1](https://datatracker.ietf.org/doc/html/rfc2068).

По сути это доработанная версия `HTTP 1.0`-протокола, на которой до сих пор работает половина интернета.

### Виртуальный хостинг

Начиная с версии `HTTP 1.1` добавляется **обязательный** заголовок `Host`: он содержит имя домена, для которого предназначен запрос и, опционально, номер порта.
Если номер порта не указан, то подразумевается, что будет использован `80` порт.

```javascript
GET /wiki/HTTP HTTP/1.0
Host: ru.wikipedia.org
```

Зачем заголовок появился и нужен настолько, что он обязателен?

До этого момента подразумевалось, что один сайт (ресурс к которому мы обращаемся) расположен на одном сервере: мы делаем запрос к абстрактному `www.site.ru`, после чего это имя превращается с помощью `DNS` в `IP`-адрес, создается соединение и веб-сервер обрабатывает запрос. Т.е. у веб-сайта есть собственный `IP`-адрес, а веб-сервер имеет несколько физических или виртуальных сетевых интерфейсов, через которые принимает запросы и отвечает на них.

Теперь же веб-сайты могут использовать один общий `IP`-адрес. Согласно протоколу `HTTP/1.1`, веб-браузер при запросе к веб-серверу указывает доменное имя веб-сайта в заголовке `Host` текущего запроса, и веб-сервер использует его для правильного выполнения запроса.

Таким образом физически все сайты расположены на одном сервере, к нему приходят запросы и далее уже по заголовку определяется с каким именно сайтом или ресурсом проводится работа. Т.е. на одном IP и порту несколько `DNS` имен.

Это позволяет существенно экономить серверные ресурсы. Если раньше даже на самый маленький сайт нужно было выделять сервер, то сейчас можно хостить множество сайтов на одной машине. От того это и называются виртуальный хостинг.

### Методы

Вводится понятие `идемпотентности` и `безопасности` метода.

#### Безопасность (Safe)

Метод `HTTP` является безопасным, если он не меняет состояние сервера. Другими словами, безопасный метод проводит операции "только чтение" (read-only).

Пример безопасного метода: `GET`.

#### Идемпотентность (Idempotent)

> Methods may also have the property of "idempotence" in that (aside from error or expiration issues)
> the side-effects of N > 0 identical requests is the same as for a single request.
>
> The methods GET, HEAD, PUT and DELETE share this property.

Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера.

Для идемпотентности нужно рассматривать только изменение фактического внутреннего состояния сервера, а возвращаемые запросами коды статуса могут отличаться: первый вызов `DELETE` (появился в `HTTP 1.1`, отвечает за удаление ресурса) вернёт код `200`, в то время как последующие вызовы вернут код `404`. При этом `DELETE` будет идемпотентным.

#### Новые методы

Добавлены новые методы: `PUT`, `DELETE` и `TRACE`.

Метод запроса `PUT` создаёт новый ресурс или заменяет представление целевого ресурса, данными представленными в теле запроса.

Разница между `PUT` и `POST` в том, что `PUT` является идемпотентным, т.е. единичный и множественные вызовы этого метода, с идентичным набором данных, будут иметь тот же результат выполнения (без сторонних эффектов), в случае с `POST`, множественный вызов с идентичным набором данных может повлечь за собой сторонние эффекты.

Если простыми словами, то `POST` всегда будет создавать новый ресурс:

```html
POST /add_row HTTP/1.1 // создаст одну строку
POST /add_row HTTP/1.1 // создаст вторую строку
POST /add_row HTTP/1.1 // создаст третью строку
```

При этом все строки будут идентичны, ведь мы создаем их с одними и теми же данными.

В то время как `PUT` должен создать только одну строку, а последующие вызовы не будут изменять состояние сервера.

Метод запроса `DELETE` удаляет указанный ресурс.

Метод `TRACE` выполняет проверку обратной связи по пути к целевому ресурсу, предоставляя механизм отладки.

### Постоянные соединения

Если не указано иного, то в `HTTP/1.1` считается, что по умолчанию соединения будут постоянными.
Добавилась возможность переиспользования уже открытого `TCP`-соединения благодаря заголовку [Keep-Alive](https://datatracker.ietf.org/doc/html/rfc2068#section-19.7.1.1).

[Преимущества](https://datatracker.ietf.org/doc/html/rfc2616#section-8.1.1): переиспользование `TCP`-соединения позволяет экономить ресурсы компьютера (процессор, память), снижается нагрузка на сеть за счет уменьшения количества пакетов, вызванных открытием `TCP`.

Также `HTTP`-запросы и ответы могут быть конвейеризированы по соединению. Эта особенность называется [HTTP Pipelining](https://datatracker.ietf.org/doc/html/rfc2068#section-8.1.2.2). Конвейерная обработка позволяет клиенту делать несколько запросов, не дожидаясь каждого ответа, что позволяет использовать одно `TCP`-соединение гораздо эффективнее и с гораздо меньшими затратами времени.

![Http Pipeline](../images/http/http_pipeline.png)

### Кеширование

Версия `HTTP 1.0` уже поддерживала кеширование, но была далеко не совершенна. В версии `HTTP 1.1` кеширование было доработано.

Были добавлены новые заголовки для более гибким управлением кешами, например, заголовок `Vary`, который отправлялся в ответ клиенту и давал указание любым промежуточным кешам кэшировать отдельный экземпляр.

Также был добавлен механизм [Cache-control](https://datatracker.ietf.org/doc/html/rfc2068#section-14.9), который определял политику кэширования.

### Современный HTTP 1.1

Протокол продолжал развиваться благодаря дополнениям. На протяжении 15 лет добавлялись новые методы, заголовки и поведение при этих заголовках.
Из простого протокола, созданного, чтобы получать `HTML` он вырос в мощный и гибкий инструмент.

/// TODO КУКИ

## HTTP 2

`HTTP/2` - вторая крупная версия сетевого протокола `HTTP`.

Главные отличия от `HTTP/1.1`:

* Бинарный
  
  `HTTP/2` пытается решить проблему выросшей задержки, существовавшую в `HTTP/1.x`, переходом на бинарный формат.

* Мультиплексирование — передача нескольких асинхронных `HTTP`-запросов по одному `TCP`-соединению.
  
    В `HTTP/1.1` для каждого запроса требуется устанавливать отдельное `TCP`-соединение.
    Мультиплексирование же позволяет браузеру выполнять множество запросов в рамках одного `TCP`-соединения.

* Сжатие заголовков методом HPACK
  
   Если мы постоянного обращаемся к серверу из одного и того же клиента, то в заголовках раз за разом посылается огромное количество повторяющихся данных. А иногда к этому добавляются ещё и куки, раздувающие размер заголовков, что снижает пропускную способность сети и увеличивает время задержки.

* Server Push — несколько ответов на один запрос

    Server push позволяет серверу снизить количество дополнительных запросов. Если он знает, что клиент собирается запросить данные, он сразу их посылает.

* Приоритизация запросов
  
  Каждому запросу можно назначить приоритет.
  Например, браузер может попросить сервер сначала загрузить `CSS`-файлы или `JavaScript`, а уже потом — `HTML` или изображения.

  Грубо говоря, представьте себе кортеж с мигалками. Каким-то файлам теперь можно назначить кортеж с мигалками и доставлять их быстрее.

## Полезные ссылки

1. [Web-технологии. Протокол HTTP | Технострим](https://www.youtube.com/watch?v=HFt7Lm7hv1E)
2. [HTTP Wikipedia](https://ru.wikipedia.org/wiki/HTTP)
3. [Mozilla Dev HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP)
4. [Computer Science Center Лекция 7. Протокол HTTP](https://www.youtube.com/watch?v=uxoGYIWCQZg)
5. [HTTP протокол - Иван Бибилов](https://www.youtube.com/watch?v=yUHlrabtEaU)
6. [HTTP и HTTPS - Вячеслав Бирюков](https://www.youtube.com/watch?v=WNVcwW7mC34&t=1550s)
7. [Простым языком об HTTP](https://habr.com/ru/post/215117/)
8. [Что надо знать о HTTP/2](https://www.youtube.com/watch?v=4yyhqMh9FcY)
9. [Путь к HTTP/2](https://habr.com/ru/post/308846/)
10. [HTTP/2: готовимся к переходу](https://habr.com/ru/company/selectel/blog/278167/)
11. [The Original HTTP as defined in 1991](https://www.w3.org/Protocols/HTTP/AsImplemented.html)
12. [Спецификация HTTP 1.0](https://www.rfc-editor.org/rfc/rfc1945)
13. [Спецификация HTTP 1.1](https://datatracker.ietf.org/doc/html/rfc2068)
14. [HTTP Caching – HTTP 1.0 vs HTTP 1.1](https://www.fir3net.com/Networking/Protocols/http-caching-http-1-0-vs-http-1-1.html)
15. [HTTP Keep-Alive, Pipelining, Multiplexing and Connection Pooling](https://www.haproxy.com/blog/http-keep-alive-pipelining-multiplexing-and-connection-pooling/)
16. [Сетевая модель OSI](https://ru.wikipedia.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_OSI)
