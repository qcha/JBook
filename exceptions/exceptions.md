# Исключения

- [Исключения](#исключения)
  - [Введение](#введение)
  - [Иерархия исключений](#иерархия-исключений)
    - [Проверяемые и непроверяемые](#проверяемые-и-непроверяемые)
    - [Иерархия](#иерархия)
      - [Классификация](#классификация)
      - [Error и Exception](#error-и-exception)
  - [Работа с исключениями](#работа-с-исключениями)
    - [Обработка исключений](#обработка-исключений)
      - [Правила try/catch/finally](#правила-trycatchfinally)
      - [Расположение catch блоков](#расположение-catch-блоков)
      - [Транзакционность](#транзакционность)
    - [Делегирование](#делегирование)
    - [Методы и практики работы с исключительными ситуацими](#методы-и-практики-работы-с-исключительными-ситуацими)
      - [Собственные исключения](#собственные-исключения)
      - [Реагирование через re-throw](#реагирование-через-re-throw)
      - [Не забывайте указывать причину возникновения исключения](#не-забывайте-указывать-причину-возникновения-исключения)
      - [Сохранение исключения](#сохранение-исключения)
      - [Логирование](#логирование)
      - [Чего нельзя делать при обработке исключений](#чего-нельзя-делать-при-обработке-исключений)
    - [Try-with-resources или try-с-ресурсами](#try-with-resources-или-try-с-ресурсами)
    - [Общие советы](#общие-советы)
      - [Избегайте генерации исключений, если их можно избежать простой проверкой](#избегайте-генерации-исключений-если-их-можно-избежать-простой-проверкой)
      - [Предпочитайте `Optional`, если отсутствие значения - не исключительная ситуация](#предпочитайте-optional-если-отсутствие-значения---не-исключительная-ситуация)
      - [Заранее обдумывайте контракты методов](#заранее-обдумывайте-контракты-методов)
      - [Предпочитайте исключения кодам ошибок и `boolean` флагам-признакам успеха](#предпочитайте-исключения-кодам-ошибок-и-boolean-флагам-признакам-успеха)
  - [Исключения и статические блоки](#исключения-и-статические-блоки)
  - [Многопоточность и исключения](#многопоточность-и-исключения)
  - [Проверяемые исключения и их необходимость](#проверяемые-исключения-и-их-необходимость)
  - [Заключение](#заключение)
  - [Полезные ссылки](#полезные-ссылки)

## Введение

> Начав заниматься программированием, мы, к своему удивлению, обнаружили, что не так уж просто заставить программы делать задуманное. Я могу точно вспомнить момент, когда я понял, что большая часть моей жизни с этих пор будет посвящена поиску ошибок в собственных программах.
>
> (c) Морис Уилкс.

Предположим, вам понадобилась программа, считывающая содержимое файла.
В целом, здесь нет ничего сложного и код, выполняющий поставленную задачу, мог бы выглядеть как-то так:

```java
    public List<String> readAll(String path) {
        BufferedReader br = new BufferedReader(new FileReader(path));
        String line;
        List<String> lines = new ArrayList<>();
        while ((line = br.readLine()) != null) {
            lines.add(line);
        }
        
        return lines;
    }
```

И это был бы вполне рабочий вариант, если бы не одно но: мы живём не в идеальном мире. Код, приведённый выше, рассчитан на то, что всё работает идеально: путь до файла указан верный, файл можно прочитать, во время чтения с файлом ничего не происходит, место хранения файла работает без ошибок и еще огромное количество предположений.

Однако, как показывает практика, мир не идеален, а нас повсюду преследуют ошибки и проблемы. Кто-то может указать путь до несуществующего файла, во время чтения может произойти ошибка, например, файл повреждён или удален в процессе чтения и т.д.

Игнорирование подобных ситуаций недопустимо, так как это ведет к нестабильно и непредсказуемо работающему коду.
Значит, на такие ситуации надо реагировать.

Самая простая реакция - это возвращать `boolean` - признак успеха или некоторый код ошибки, например, какое-то число.
Пусть, 0 - это код удачного завершения приложения, 1 - это аварийное завершение и т.д.
Мы получаем код возврата и уже на него реагируем.

Подобный ход имеет право на жизнь, однако, он крайне неудобен в повседневной разработке с её тысячами возможных ошибок и проблемных ситуаций.

Во-первых, он слишком немногословен, так как необходимо помнить что означает каждый код возврата, либо постоянно сверяться с таблицей расшифровки, где они описаны.

Во-вторых, такой подход предоставляет не совсем удобный способ обработки возникших ошибок. Более того, нередки ситуации, когда в месте возникновения ошибки непонятно, как реагировать на возникшую проблему. В таком случае было бы удобнее делегировать обработку ошибки вызывающему коду, до места, где будет понятно как реагировать на ошибку.

В-третьих, и это, на мой взгляд, самое главное - это небезопасно, так как подобный способ можно легко проигнорировать.

> Lots of newbie's coming in from the C world complain about exceptions and the fact that they have to put exception handling all over the place—they want to just write their code. But that's stupid: most C code never checks return codes and so it tends to be very fragile. If you want to build something really robust, you need to pay attention to things that can go wrong, and most folks don't in the C world because it's just too damn hard.
One of the design principles behind Java is that I don't care much about how long it takes to slap together something that kind of works. The real measure is how long it takes to write something solid.
>
> In Java you can ignore exceptions, but you have to willfully do it. You can't accidentally say, "I don't care." You have to explicitly say, "I don't care."
>
> (c) James Gosling.

Поэтому, в `Java` используется другой механизм работы с такими ситуациями: исключения.

Что такое исключение? В некотором смысле можно сказать, что исключение - это некоторое сообщение, уведомляющее о проблеме, незапланированном поведении.

В нашем примере с чтением содержимого файла, источником такого сообщения может являться `BufferedReader` или `FileReader`. Сообщению необходим получатель/обработчик, чтобы перехватить его и что-то сделать, как-то отреагировать.

Важно понимать, что генерация исключения ломает поток выполнения программы, так как либо это сообщение будет перехвачено и обработано каким-то зарегистрированным получателем, либо программа завершится.

Что значит "ломает поток выполнения программы"?

Представьте, что по дороге едет грузовик. Движение машины и есть поток выполнения программы. Вдруг водитель видит, что впереди разрушенный мост - исключение, ошибка. Теперь он либо поедет по объездной дороге, т.е перехватит и отреагирует на исключение, либо остановится и поездка будет завершена.

![Объездная](../images/exception/exception_ob.png)

Исключения могут быть разных типов, под разные ситуации, а значит и получателей(обработчиков) может быть несколько - на каждый отдельный тип может быть своя реакция, свой обработчик.

Исключение также может хранить информацию о возникшей проблеме: причину, описание-комментарий и т.д.
Исходя из описания можно сказать, что исключение - это объект некоторого, специально для этого предназначенного, класса. Так как проблемы и ошибки бывают разного рода, их можно классифицировать и логически разделить, значит и классы исключений можно выстроить в некоторую иерархию.

Как генерировать исключения и регистрировать обработчики мы рассмотрим позднее, а пока давайте взглянем на иерархию этих классов.

## Иерархия исключений

Ниже приведена иерархия исключений:

![Exception Hierarchy](../images/exception/exceptions.png)

*Картинка большая, чтобы лучше запоминалась.*

Для начала разберем загадочные подписи `checked` и `unchecked` на рисунке.

### Проверяемые и непроверяемые

Все исключения в `Java` делятся на два типа: проверяемые (`checked`) и непроверяемые исключения (`unchecked`).

Как видно на рисунке, `java.lang.Throwable` и `java.lang.Exception` относятся к проверяемым исключениям, в то время как `java.lang.RuntimeException` и `java.lang.Error` - это непроверяемые исключения.

Принадлежность к тому или иному типу каждое исключение наследует от родителя.
Это значит, что наследники `java.lang.RuntimeException` будут `unchecked` исключениями, а наследники `java.lang.Exception` - `checked`.

Что это за разделение?

В первую очередь напомним, что `Java` - это компилируемый язык, а значит, помимо `runtime`(время выполнения кода), существует ещё и `compile-time`(то, что происходит во время компиляции).

Так вот проверяемые исключения - это исключения, на которые разработчик **обязан** отреагировать, т.е написать обработчики, и наличие этих обработчиков будет проверено на этапе компиляции. Ваш код не будет скомпилирован, если какое-то проверяемое исключение не обработано, компилятор этого не допустит.

Непроверяемые исключения - это исключения времени выполнения. Компилятор не будет от вас требовать обработки непроверяемых исключений.

В чём же смысл этого разделения на проверяемые и непроверяемые исключения?

Я думаю так: проверяемые исключения в `Java` - это ситуации, которые разработчик никак не может предотвратить и исключение является одним из вариантов **нормальной** работы кода.

Например, при чтении файла требуется обрабатывать `java.io.FileNotFoundException` и `java.io.IOException`, которые является потомками `java.io.Exception`.

Потому, что отсутствие файла или ошибка работы с вводом/выводом - это вполне допустимая ситуация при чтении.

С другой стороны, `java.lang.RuntimeException` - это скорее ошибки **разработчика**.
Например, `java.lang.NullPointerException` - это ошибка обращения по `null` ссылке, данную ситуацию можно предотвратить: проверить ссылку на `null` перед вызовом.

Представьте, что вы едете по дороге, так вот предупредительные знаки - это проверяемые исключения. Например, знак "Осторожно, дети!" говорит о том, что рядом школа и дорогу может перебежать ребенок. Вы обязаны отреагировать на это, не обязательно ребенок перебежит вам дорогу, но вы не можете это проконтролировать, но в данном месте - это нормальная **ситуация**, ведь рядом школа.

Делать абсолютно все исключения проерямыми - не имеет никакого смысла, потому что вы просто с ума сойдете, пока будете писать обработчики таких ситуаций. Да и зачастую это будет только мешать: представьте себе дорогу, которая утыкана постоянными предупредительными знаками, на которые вы должны реагировать. Ехать по такой дороге будет крайне утомительно.

> Разделение на проверяемые и непроверяемые исключения существует только в `Java`, в других языках программирования, таких как `Scala`, `Groovy`, `Kotlin` или `Python`, все исключения непроверяемые.
>
> Это довольно холиварная тема и свои мысли по ней я изложу в конце статьи.

Теперь рассмотрим непосредственно иерархию исключений.

### Иерархия

Итак, корнем иерархии является `java.lang.Throwable`, у которого два наследника: `java.lang.Exception` и `java.lang.Error`.
В свою очередь `java.lang.Exception` является родительским классом для `java.lang.RuntimeException`.

> Занятно, что класс `java.lang.Throwable` назван так, как обычно называют интерфейсы, что иногда вводит в заблуждение новичков. Однако помните, что это класс! Запомнить это довольно просто, достаточно держать в уме то, что исключения могут содержать состояние (например, информация о возникшей проблеме).

Так как в `Java` все классы являются наследниками `java.lang.Object`, то и исключения (будучи тоже классами) наследуют все стандартные методы, такие как `equals`, `hashCode`, `toString` и т.д.

Раз мы работаем с классами, то можно с помощью наследования создавать свои собственные иерархии исключений, добавляя в них какое-то специфическое поведение и состояние.

Чтобы создать свой собственный класс исключение необходимо отнаследоваться от одного из классов в иерархии исключений. При этом помните, что наследуется еще и тип исключения: проверяемое или непроверяемое.

#### Классификация

Каждый тип исключения отвечает за свою область ошибок.

1. `java.lang.Exception`

    Это ситуации, которые разработчик никак не может предотвратить, например, не получилось закрыть файловый дескриптор или отослать письмо, и исключение является одним из вариантов **нормальной** работы кода.

    Это проверяемые исключения, мы **обязаны** на такие исключения реагировать, это будет проверено на этапе компиляции.

    Пример: `java.io.IOException`, `java.io.FileNotFoundException`.

2. `java.lang.RuntimeException`

    Это ситуации, когда основной причиной ошибки является сам разработчик, например, происходит обращение к `null` ссылке, деление на ноль, выход за границы массива и т.д. При этом исключение **не** является одним из вариантов **нормальной** работы кода.

    Это непроверяемые исключения, реагировать на них или нет решает разработчик.

    Пример: `java.lang.NullPointerException`.

3. `java.lang.Error`

    Это критические ошибки, аварийные ситуации, после которых мы с трудом или вообще не в состоянии продолжить работу. Например, закончилась память, переполнился стек вызовов и т.д.

    Это непроверяемые исключения, реагировать на них или нет решает разработчик.

    Реагировать на подобные ошибки следует только в том случае, если разработчик точно знает как поступить в такой ситуации. Перехватывать такие ошибки не рекомендуется, так как чаще всего разработчик не знает как реагировать на подобного рода аварийные ситуации.

Теперь перейдем к вопросу: в чем же разница между `java.lang.Error` и `java.lang.Exception`?

#### Error и Exception

Все просто. Исключения `java.lang.Error` - это более серьезная ситуация, нежели `java.lang.Exception`.
Это серьезные проблемы в работе приложения, которые тяжело исправить, либо вообще неясно, можно ли это сделать.

Это не просто исключительная ситуация - это ситуация, в которой работоспособность всего приложения под угрозой! Например, исключение `java.lang.OutOfMemoryError`, сигнализирующее о том, что кончается память или `java.lang.StackOverflowError` – переполнение стека вызовов, которое можно встретить при бесконечной рекурсии.

Согласитесь, что если не получается преобразовать строку к числу, то это не та ситуация, когда все приложение должно завершаться. Это ситуация, после которой приложение **может продолжить** работать.
Да, это неприятно, что вы не смогли найти файл по указанному пути, но не настолько критично, как переполнение стека вызовов.

Т.е разница - в **логическом разделении**.

Поэтому, `java.lang.Error` и его наследники используются только для критических ситуаций.

## Работа с исключениями

### Обработка исключений

Корнем иерархии является класс `java.lang.Throwable`, т.е. что-то "бросаемое".
А раз исключения бросаются, то для обработки мы будем ловить их!

В `Java` исключения ловят и обрабатывают с помощью конструкции `try/catch/finally`.

При заключении кода в один или несколько блоков `try` указывается потенциальная возможность выбрасывания исключения в этом месте, все операторы, которые могут сгенерировать исключение, помещаются в этом блоке.

В блоках `catch` перечисляются исключения, на которые решено реагировать. Тут определяются блоки кода, предназначенные для решения возникших проблем. Это и есть объявление тех самых получателей/обработчиков исключений.

Пример:

```java
public class ExceptionHandling {
    public static void main(String[] args) {
        try {
             // код
        } catch(FileNotFoundException fnf) {
            // обработчик на FileNotFoundException
        }
    }
}
```

Тот тип исключения, что указывается в `catch` блоке можно расценивать как фильтр, который перехватывает все исключения того типа, что вы указали и всех его потомков, расположенных ниже по иерархии.

Представьте себе просеивание муки. Это процесс целью которого является удаление посторонних частиц, отличающихся по размерам от частиц муки. Вы просеиваете через несколько фильтров муку, так как вам не нужны крупные комочки, осколки и другие посторонние частицы, вам нужна именно мука определенного качества. И в зависимости от выставленных фильтров вы будете перехватывать разные частицы, комочки и т.д. Эти частицы и есть исключения. И если выставляется мелкий фильтр, то вы словите как крупные частицы, так и мелкие.

Точно также и в `Java`, ставя фильтр на `java.lang.RuntimeException` вы ловите не только `java.lang.RuntimeException`, но и всех его наследников! Ведь эти потомки - это **тоже** `runtime` ошибки!

В блоке `finally` определяется код, который будет всегда выполнен, независимо от результата выполнения блоков `try/catch`. Этот блок будет выполняться независимо от того, выполнился или нет блок `try` до конца, было ли сгенерировано исключение или нет, и было ли оно обработано в блоке `catch` или нет.

Пример:

```java
public class ExceptionHandling {
    public static void main(String[] args) {
        try {
             // some code
        } catch(FileNotFoundException fnf) {
            // обработчик 1
        } catch(RuntimeException re) {
            // обработчик 2
        } finally {
            System.out.println("Hello from finally block.");
        }
    }
}
```

В примере выше объявлен `try` блок с кодом, который потенциально может сгенерировать исключения, после `try` блока описаны два обработчика исключений, на случай генерации `FileNotFoundException` и на случай генерации любого `RuntimeException`.
Объект исключения доступен по ссылке `exception`.

#### Правила try/catch/finally

1. Блок `try` находится перед блоком `catch` или `finally`. При этом должен присутствовать хотя бы один из этих блоков.
2. Между `try`, `catch` и `finally` не может быть никаких операторов.
3. Один блок `try` может иметь несколько `catch` блоков. В таком случае будет выполняться первый подходящий блок.

    Поэтому сначала должны идти более специальные блоки обработки исключений, а потом уже более общие.

4. Блок `finally` будет выполнен всегда, кроме случая, когда `JVM` преждевременно завершит работу или будет сгенерировано исключение непосредственно в самом `finally` блоке.
5. Допускается использование вложенных конструкций `try/catch/finally`.

    ```java
    public class ExceptionHandling {
        public static void main(String[] args) {
            try {
                 try {
                    // some code
                } catch(FileNotFoundException fnf) {
                    // обработчик 1
                }
            } catch(RuntimeException re) {
                // обработчик 2
            } finally {
                System.out.println("Hello from finally block.");
            }
        }
    }
    ```

---

**Вопрос**:

Каков результат выполнения примера выше, если в блоке `try` не будет сгенерировано ни одного исключения?

**Ответ**:

Будет выведено на экран: "Hello from finally block.".

Так как блок `finally` выполняется **всегда**.

---

**Вопрос**:

Теперь немного видоизменим код, каков результат выполнения будет теперь?

```java
public class ExceptionHandling {
  public static void main(String[] args) {
    try {
         return;
    } finally {
         System.out.println("Hello from finally block");
    }
  }
}
```

**Ответ**:

На экран будет выведено: `Hello from finally block`.

---

**Вопрос**:

Плохим тоном считается прямое наследование от `java.lang.Throwable`.
Это **строго** не рекомендуется делать, почему?

**Ответ**:

Наследование от наиболее общего класса, а в данном случае от корневого класса иерархии, усложняет обработку ваших исключений. Проблему надо стараться локализовать, а не делать ее описание/объявление максимально общим. Согласитесь, что `java.lang.IllegalArgumentException` говорит гораздо больше, чем `java.lang.RuntimeException`. А значит и реакция на первое исключение будет более точная, чем на второе.

---

Далее приводится несколько примеров перехвата исключений разных типов:

Обработка `java.lang.RuntimeException`:

```java
try {
    String numberAsString = "one";
    Double res = Double.valueOf(numberAsString);
} catch (RuntimeException re) {
    System.err.println("Error while convert string to double!");
}
```

Результатом будет печать на экран: `Error while convert string to double!`.

Обработка `java.lang.Error`:

```java
try {
    throw new Error();
} catch (RuntimeException re) {
    System.out.println("RuntimeException");
} catch (Error error) {
    System.out.println("ERROR");
}
```

Результатом будет печать на экран: `ERROR`.

#### Расположение catch блоков

Как уже было сказано, один блок `try` может иметь несколько `catch` блоков. В таком случае будет выполняться первый подходящий блок.

Это значит, что порядок расположения `catch` блоков важен.

Рассмотрим ситуацию, когда некоторый используемый нами метод может выбросить два разных исключения:

```java
void method() throws Exception {
    if (new Random((System.currentTimeMillis())).nextBoolean()) {
        throw new Exception();
    } else {
       throw new IOException();
    }
}
```

> Конструкция `new Random((System.currentTimeMillis())).nextBoolean()` генерирует нам случайное значение `false` или `true`.

Для обработки исключений этого метода написан следующий код:

```java
try {
  method();
} catch (Exception e) {
  // Обработчик 1
} catch (IOException e) {
  // Обработчик 2
}
```

Все ли хорошо с приведенным выше кодом?
Нет, код выше неверен, так как обработчик `java.io.IOException` в данном случае недостижим. Все дело в том, что первый обработчик, ответсвенный за `Exception`, перехватит все исключения, а значит не может быть ситуации, когда мы сможем попасть во второй обработчик.

Снова вспомним пример с мукой, приведенный в начале.

Так вот песчинка, которую мы ищем, это и есть наше исключение, а каждый фильтр это `catch` блок.

Если первым установлен фильтр *ловить все, что является Exception и его потомков*, то до фильтра *ловить все, что является IOException и его потомков* ничего не дойдет, так как верхний фильтр уже перехватит все песчинки.

Отсюда следует правило:

> Сначала должны идти более специальные блоки обработки исключений, а потом уже более общие.

А что если на два разных исключения предусмотрена одна и та же реакция? Написание двух одинаковых `catch` блоков не приветствуется, ведь дублирование кода - это зло.

Поэтому допускается объединить два `catch` блока с помощью `|`:

```java
try {
    method2();
} catch (IllegalArgumentException | IndexOutOfBoundsException e) {
    // Обработчик
}
```

---

**Вопрос**:

Есть ли способ перехватить **все** возможные исключения?

**Ответ**:

Есть! Если взглянуть еще раз на иерархию, то можно отметить, что `java.lang.Throwable` является родительским классом для всех исключений, а значит, чтобы поймать все, необходимо написать что-то в виде:

```java
try {
  method();
} catch (Throwable t) {
  // Обработчик
}
```

Однако, делать так **не рекомендуется**, что наталкивает на следующий вопрос.

---

**Вопрос**:

Почему перехватывать `java.lang.Throwable` - плохо?

**Ответ**:

Дело в том, что написав:

```java
try {
  method();
} catch (Throwable t) {
  // catch all
}
```

Будут перехвачены абсолютно все исключения: и `java.lang.Exception`, и `java.lang.RuntimeException`, и `java.lang.Error`, и все их потомки.

И как реагировать на **все**? При этом надо учесть, что обычно на `java.lang.Error` исключений вообще не ясно как реагировать. А значит, мы можем неверно отреагировать на исключение и вообще потерять данные. А ловить то, что не можешь и не собирался обрабатывать - плохо.

Поэтому перехватывать все исключения - плохая практика.

---

**Вопрос-Тест**:

Что будет выведено на экран при запуске данного куска кода?

```java
public static void main(String[] args) {
    try {
        try {
            throw new Exception("0");
        } finally {
            if (true) {
                throw new IOException("1");
            }

            System.err.println("2");
        }
    } catch (IOException ex) {
        System.err.println(ex.getMessage());
    } catch (Exception ex) {
        System.err.println("3");
        System.err.println(ex.getMessage());
    }
}
```

**Ответ**:

При выполнении данного кода выведется "1".
Давайте разберем почему.

Мы кидаем исключение во вложенном `try` блоке: `throw new Exception("0");`.

После этого поток программы ломается и мы попадаем в `finally` блок:

```java
if (true) {
    throw new IOException("1");
}

System.err.println("2");
```

Здесь мы гарантированно зайдем в `if` и кинем уже новое исключение: `throw new IOException("1");`.
При этом вся информация о первом исключении будет потеряна! Ведь мы никак не отреагировали на него, а в `finally` блоке и вовсе 'перезатерли' новым исключением.

На `try`, оборачивающий наш код, настроено два фильтра: первый на `IOException`, второй на `Exception`.

Так как порядок расположения задан так, что мы прежде всего смотрим на `IOException`, то и сработает этот фильтр, который выполнит следующий код:

```java
System.err.println(ex.getMessage());
```

Именно поэтому выведется `1`.

---

#### Транзакционность

Важным моментом, который нельзя пропустить, является то, что `try` блок **не транзакционный**.

> Под термином `транзакционность` я имею в виду то, что либо действия будут выполнены целиком и успешно, либо не будут выполнены вовсе.

Что это значит?

Это значит, что при возникновении исключения в `try` блоке все совершенные действия **не** откатываются к изначальному состоянию, а так и остаются совершенными.
Все выделенные ресурсы так и остаются занятыми, в том числе и при возникновении исключения.

По сути именно поэтому и существует `finally` блок, так как туда, как уже было сказано выше, мы зайдем **в любом** случае, то там и освобождают выделенные ресурсы.

---

**Вопрос**:

Работа с объектами из `try` блока в других блоках невозможна:

```java
public class ExceptionExample {
    public static void main(String[] args) {
        try {
            String line = "hello";
        } catch (Exception e) {
            System.err.println(e);
        }

        // Compile error
        System.out.println(line); // Cannot resolve symbol `line`
    }
}
```

Почему?

**Ответ**:

Потому что компилятор не может нам гарантировать, что объекты, объявленные в `try`-блоке, были созданы.

Ведь могло быть сгенерировано исключение. Тогда после места, где было сгенерировано исключение, оставшиеся действия не будут выполнены, а значит возможна ситуация, когда объект не будет создан. Следовательно и работать с ним нельзя.

---

Вернемся к примеру с грузовиком, чтобы объяснить все вышесказанное.

![Объездная](../images/exception/exception_ob.png)

Объездная здесь - это `catch` блок, реакция на исключительную ситуацию. Если добавить еще несколько объездных дорог, несколько `catch` блоков, то водитель выберет наиболее подходящий путь, наиболее подходящий и удобный `catch` блок, что объясняет важность расположения этих блоков.

Транзакционность на этом примере объясняется тем, что если до этого водитель где-то оплатил проезд по мосту, то деньги ему автоматически не вернутся, необходимо будет написать в поддержку или куда-то пожаловаться на управляющую компанию.

### Делегирование

Выше было разобрано то, как обрабатывать исключения. Однако, иногда возникают ситуации, когда в нет конкретного понимания того, как обрабатывать возникшее исключение. В таком случае имеет смысл делегировать задачу обработки исключения коду, который вызвал ваш метод, так как вызывающий код чаще всего обладает более обширными сведениями об источнике проблемы или об операции, которая сейчас выполняется.

Делегирование исключения производится с помощью ключевого слова `throws`, которое добавляется после сигнатуры метода.

Пример:

```java
// Код написан только для ознакомительной цели, не стоит с него брать пример!
String readLine(String path) throws IOException {
    BufferedReader br = new BufferedReader(...);
    String line = br.readLine();

    return line;
}
```

Таким образом обеспечивается передача объявленного исключения в место вызова метода. И то, **как** на него реагировать уже становится заботой вызывающего этот метод.
Поэтому реагировать и писать обработчики на те исключения, которые мы делегировали, внутри метода уже не надо.

Механизм `throws` введен для проброса проверяемых исключений.

Разумеется, с помощью `throws` можно описывать делегирование как проверяемых, так и непроверяемых исключений.
Однако перечислять непроверяемые не стоит, такие исключения не контролируются в `compile time`.

Перечисление непроверяемых исключений бессмысленно, так как это примерно то же самое, что перечислять все, что может с вами случиться на улице.

Теперь пришла пора рассмотреть методы обработки исключительных ситуаций.

### Методы и практики работы с исключительными ситуацими

Главное и основное правило при работе с исключениями звучит так:

> На исключения надо либо **реагировать**, либо **делегировать**, но ни в коем случае не **игнорировать**.

Определить когда надо реагировать, а когда делегировать проще простого. Задайте вопрос: "Знаю ли я как реагировать на это исключение?".

Если ответ "да, знаю", то реагируйте, пишите обработчик и код, отвечающий за эту реакцию, если не знаете что делать с исключением, то **делегируйте** вызывающему коду.

#### Собственные исключения

Выше мы уже затронули то, что исключения это те же классы и объекты.
И иногда удобно выстроить свою иерархию исключений, заточенных под конкретную задачу. Дабы более гибко обрабатывать и реагировать на те исключительные ситуации, которые специфичны решаемой задаче.

Например, пусть есть некоторый справочник:

```java
class Catalog {
    Person findPerson(String name);
}
```

В данном случае нам надо обработать ситуации, когда `name` является `null`, когда в каталоге нет пользователя с таким именем.

Если генерировать на все ситуации `java.lang.Exception`, то обработка ошибок будет крайне неудобной.
Более того, хотелось бы явно выделить ошибку, связанную с тем, что пользователя такого не существует.
Очевидно, что стандартное исключение для этого случая не существует, а значит вполне логично создать свое.

```java
class PersonNotFoundException extends RuntimeException {
    private String name;

    // some code
}
```

Обратите внимание, что имя `Person`, по которому в каталоге не смогли его найти, выделено в свойство класса `name`.

Теперь при использовании этого метода проще реагировать на различные ситуации, такие как `null` вместо имени, а проблему с отсутствием `Person` в каталоге можно отдельно вынести в свой `catch` блок.

#### Реагирование через re-throw

Часто бывает необходимо перехватить исключение, сделать запись о том, что случилось (в файл лога, например) и делегировать его вызывающему коду.
Как уже было сказано выше, в рамках конструкции `try/catch/finally` можно сгенерировать другое исключение.

Такой подход называется `re-throw`.

Исключение перехватывается в `catch` блоке, совершаются необходимые действия, например, запись в лог или создание нового, более конкретного для контекста задачи, исключения и повторная генерация исключения.

Как это выглядит на практике:

```java
try {
    Reader readerConf = ....
    readerConf.readConfig();
} catch(IOException ex) {
    System.err.println("Log exception: " + ex);
    throw new ConfigException(ex);
}
```

Во время чтения конфигурационного файла произошло исключение `java.io.IOException`, в `catch` блоке оно было перехвачено, сделана запись в консоль о проблеме, после чего было создано новое, более конкретное, исключение `ConfigException`, с указанием причины (перехваченное исключение, ссылка на которое `ex`) и оно было проброшено дальше.

По итогу, из метода с приведенным кодом, в случае ошибки чтения конфигурации, будет выброшено `ConfigException`.

Для чего мы здесь так поступили?

Это полезно для более гибкой обработки исключений.
В примере выше чтение конфигурации генерирует слишком общее исключение, так как `java.io.IOException` это довольно общее исключение, но проблема в примере выше понятна: работа с этим конфигурационным файлом невозможна.

Значит и сообщить лучше именно как о том, что это не абстрактный `java.io.IOException`, а именно `ConfigException`. При этом, так как перехваченное исключение было передано новому в конструкторе, т.е. указалась причина возникновения (cause) `ConfigException`, то при выводе на консоль или обработке в вызывающем коде будет понятно почему `ConfigException` был создан.

Также, можно было добавить еще и текстовое описание к сгенерированному `ConfigException`, более подробно описывающее произошедшую ситуацию.

Еще одной важной областью применения `re-throw` бывает преобразование проверяемых исключений в непроверяемые.
В `Java 8` даже добавили исключение `java.io.UncheckedIOException`, которое предназначено как раз для того, чтобы сделать `java.io.IOException` непроверяемым, обернуть в `unchecked` обертку.

Пример:

```java
try {
    Reader readerConf = ....
    readerConf.readConfig();
} catch(IOException ex) {
    System.err.println("Log exception: " + ex);
    throw new UncheckedIOException(ex);
}
```

#### Не забывайте указывать причину возникновения исключения

В предыдущем пункте мы создали собственное исключение, которому указали причину: перехваченное исключение, `java.io.IOException`.

Чтобы понять как это работает, давайте рассмотрим наиболее важные поля класса `java.lang.Throwable`:

```java
public class Throwable implements Serializable {

    /**
     * Specific details about the Throwable.  For example, for
     * {@code FileNotFoundException}, this contains the name of
     * the file that could not be found.
     *
     * @serial
     */
    private String detailMessage;

    // ...


    /**
     * The throwable that caused this throwable to get thrown, or null if this
     * throwable was not caused by another throwable, or if the causative
     * throwable is unknown.  If this field is equal to this throwable itself,
     * it indicates that the cause of this throwable has not yet been
     * initialized.
     *
     * @serial
     * @since 1.4
     */
    private Throwable cause = this;

    // ...
}
```

Все исключения, будь то `java.lang.RuntimeException`, либо `java.lang.Exception` имеют необходимые конструкторы для инициализации этих полей.

> При создании собственного исключения не пренебрегайте этими конструкторами!

Поле `cause` используются для указания родительского исключения, причины. Например, выше мы перехватили `java.io.IOException`, прокинув свое исключение вместо него. Но причиной того, что наш код выкинул `ConfigException` было именно исключение `java.io.IOException`. И эту причину нельзя игнорировать.

Представьте, что код, использующий ваш метод также перехватил `ConfigException`, пробросив какое-то своё исключение, а это исключение снова кто-то перехватил и пробросил свое. Получается, что истинная причина будет просто **потеряна**! Однако, если каждый будет указывать `cause`, истинного виновника возникновения исключения, то вы всегда сможете обнаружить по этому стеку виновника.

Для получения причины возникновения исключения существует метод [getCause](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Throwable.html#getCause()).

```java
public class ExceptionExample {
    public Config readConfig() throws ConfigException { // (1)
      try {
        Reader readerConf = ....;
        readerConf.readConfig();
      } catch (IOException ex) {
          System.err.println("Log exception: " + ex);
          throw new ConfigException(ex); // (2)
      }
    }

    public void run() {
        try {
            Config config = readConfig(); // (3)
        } catch (ConfigException e) {
            Throwable t = e.getCause(); // (4)
        }
    }
}
```

В коде выше:

1. В строке (1) объявлен метод `readConfig`, который может выбросить `ConfigException`.
2. В строке (2) создаётся исключение `ConfigException`, в конструктор которого передается `IOException` - причина возникновения.
3. `readConfig` вызывается в (3) строке кода.
4. А в (4) вызван метод `getCause` который и вернёт причину возникновения `ConfigException` - `IOException`.

#### Сохранение исключения

Исключения необязательно генерировать, пробрасывать и так далее.
Выше уже упоминалось, что исключение - это `Java`-объект. А значит, его вполне можно присвоить переменной или свойству класса, передать по ссылке в метод и т.д.

```java
class Reader {
    // A holder of the last IOException encountered
    private IOException lastException;

    // some code
    
    public void read() {
        try {
            Reader readerConf = ....
            readerConf.readConfig();
        } catch(IOException ex) {
            System.err.println("Log exception: " + ex);
            lastException = ex;
        }
    }
}
```

Генерация исключения это довольно дорогостоящая операция. Кроме того, исключения ломают поток выполнения программы. Чтобы не ломать поток выполнения, но при этом иметь возможность в дальнейшем отреагировать на исключительную ситуацию можно присвоить ее свойству класса или переменой.

Подобный прием использован в `java.util.Scanner`, где генерируемое исключение чтения потока сохраняется в свойство класса `lastException`.

Еще одним способом применения сохранения исключения может являться ситуация, когда надо сделать N операций, какие-то из них могут быть не выполнены и будет сгенерировано исключение, но реагировать на эти исключения будут позже, скопом.

Например, идет запись в базу данных тысячу строк построчно.
Из них 100 записей происходит с ошибкой.
Эти исключения складываются в список, а после этот список передается специальному методу, который по каждой ситуации из списка как-то отреагирует.
Т.е пока делаете операцию, копите ошибки, а потом уже реагируете.

Это похоже на то, как опрашивают 1000 человек, а негативные отзывы/голоса записывают, после чего реагируют на них. Согласитесь, было бы глупо после каждого негативного отзыва осуществлять реакцию, а потом снова возвращаться к толпе и продолжать опрос.

```java
class Example {
    private List<Exception> exceptions;

    // some code
    
    public void parse(String s) {
        try {
            // do smth
        } catch(Exception ex) {
            exceptions.add(ex);
        }
    }

    private void handleExceptions()  {
        for(Exception e : exceptions) {
            System.err.println("Log exception: " + e);
        }
    }
}
```

#### Логирование

Когда логировать исключение?

В большинстве случаев лучше всего логировать исключение в месте его обработки. Это связано с тем, что именно в данном месте кода достаточно информации для описания возникшей проблемы - реакции на исключение. Кроме этого, одно и то же исключение при вызове одного и того же метода можно перехватывать в разных местах программы.

Также, исключение может быть частью ожидаемого поведения. В этом случае нет необходимости его логировать.

Поэтому не стоит преждевременно логировать исключение, например:

```java
/**
 * Parse date from string to java.util.Date.
 * @param date as string 
 * @return Date object.
 */
public static Date from(String date) {
    try {
        DateFormat format = new SimpleDateFormat("MMMM d, yyyy", Locale.ENGLISH);
        return format.parse(date);
    }  catch (ParseException e) {
        logger.error("Can't parse ")
        throw e;
    }
}
```

Здесь `ParseException` является частью ожидаемой работы, в ситуациях, когда строка содержит невалидные данные.
Раз происходит **делегирование** исключения выше (с помощью `throw`), то и там, где его будут обрабатывать и лучше всего логировать, а эта запись в лог будет избыточной. Хотя бы потому, что в месте обработки исключения его тоже залогируют!

Подробнее о [логировании](../other/logging.md).

#### Чего нельзя делать при обработке исключений

1. Старайтесь не игнорировать исключения.
  
     В частности, никогда не пишите подобный код:

    ```java
        try {
            Reader readerConf = ....
            readerConf.readConfig();
        } catch(IOException e) {
            e.printStackTrace();
        }
    ```

2. Не следует писать 'универсальные' блоки обработки исключений.

    Ведь очень трудно представить себе метод, который одинаково реагировал бы на все возникающие проблемы.
  
    Также программный код может измениться, а 'универсальный' обработчик исключений будет продолжать обрабатывать новые типы исключений одинаково.

    Поэтому таких ситуаций лучше не допускать.

3. Старайтесь не преобразовывать более конкретные исключения в более общие.

    В частности, например, не следует `java.io.IOException` преобразовывать в `java.lang.Exception` или в `java.lang.Throwable`.

    Чем с более конкретными исключениями идет работа, тем проще реагировать и принимать решения об их обработке.

4. Старайтесь не злоупотреблять исключениями.

    Если исключение можно не допустить, например, дополнительной проверкой, то лучше так и сделать.
  
    Например, можно обезопасить себя от `java.lang.NullPointerException` простой проверкой:

    ```java
      if(ref != null) {
          // some code
      }
    ```

### Try-with-resources или try-с-ресурсами

Как уже говорилось выше про `finally` блок, код в нем выполняется в любом случае, что делает его отличным кандидатом на место по освобождению ресурсов, учитывая нетранзакционность блока `try`.

Чаще всего за закрытие ресурса будет отвечать код, наподобие этого:

```java
try {
    // code
} finally {
    resource.close();
}
```

Освобождение ресурса (например, освобождение файлового дескриптора) - это поведение.

> А за поведение в `Java` отвечают [интерфейсы](../oop/interface.md).

Это наталкивает на мысль, что нужен некоторый общий интерфейс, который бы реализовывали все классы, для которых необходимо выполнить какой-то код по освобождению ресурсов, т.е выполнить 'закрытие' в `finally` блоке и еще удобнее, если бы этот однообразный `finally` блок не нужно было писать каждый раз.

Поэтому, начиная с `Java 7`, была введена конструкция `try-with-resources` или `TWR`.

Для этого объявили специальный интерфейс `java.lang.AutoCloseable`, у которого один метод:

```java
void close() throws Exception;
```

Все классы, которые будут использоваться так, как было описано выше, должны реализовать или `java.lang.Closable`, или `java.lang.AutoCloseable`.

В качестве примера, напишем код чтения содержимого файла и представим две реализации этой задачи: используя и не используя `try-with-resources`.

Без использования `try-with-resources` (пример ниже плох и служит только для демонстрации объема необходимого кода):

```java
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader(path));
    // read from file
} catch (IOException e) {
    // catch and do smth
} finally {
    try {
        if (br != null) {
            br.close();
        }
    } catch (IOException ex) {
        // catch and do smth
    }
}
```

А теперь то же самое, но в `Java 7+`:

```java
try (FileReader fr = new FileReader(path);
    BufferedReader br = new BufferedReader(fr)) {
         // read from file
} catch (IOException e) {
         // catch and do smth
}
```

По возможности пользуйтесь **только** `try-with-resources`.

> Помните, что без реализации `java.lang.Closable` или `java.lang.AutoCloseable` ваш класс не будет работать с `try-with-resources` так, как показано выше.

---

**Вопрос**:

Получается, что используя `TWR` мы не пишем код для закрытия ресурсов, но при их закрытии может же тоже быть исключение! Что произойдет?

**Ответ**:

Точно так же, как и без `TWR`, исключение выбросится так, будто оно было в `finally`-блоке.

Помните, что `TWR`, грубо говоря, просто добавляет вам блок кода вида:

```java
finally {
    resource.close();
}
```

---

**Вопрос**:

Является ли безопасной конструкция следующего вида?

```java
try (BufferedWriter bufferedWriter
        = new BufferedWriter(new OutputStreamWriter(new FileOutputStream("a")))) {
}
```

**Ответ:**

Не совсем, если конструктор `OutputStreamWriter` или `BufferedWriter` выбросит исключение, то `FileOutputStream` закрыт **не будет**.

Пример, демонстрирующий это:

```java
public class Main {
    public static void main(String[] args) throws Exception {
        try (ThrowingAutoCloseable throwingAutoCloseable
                     = new ThrowingAutoCloseable(new PrintingAutoCloseable())) { // (1)
        }
    }

    private static class ThrowingAutoCloseable implements AutoCloseable { // (2)
        private final AutoCloseable other;

        public ThrowingAutoCloseable(AutoCloseable other) {
            this.other = other;
            throw new IllegalStateException("I always throw"); // (3)
        }

        @Override
        public void close() throws Exception {
            try {
                other.close(); // (4)
            } finally {
                System.out.println("ThrowingAutoCloseable is closed");
            }
        }
    }

    private static class PrintingAutoCloseable implements AutoCloseable { // (5)
        public PrintingAutoCloseable() {
            System.out.println("PrintingAutoCloseable created"); // (6)
        }

        @Override
        public void close() {
            System.out.println("PrintingAutoCloseable is closed"); // (7)
        }
    }
}
```

1. В строке (1) происходит заворачивание одного ресурса в другой, аналогично `new BufferedWriter(new OutputStreamWriter(new FileOutputStream("a")))`.
2. `ThrowingAutoCloseable` (2) - такой `AutoCloseable`, который всегда бросает исключение (3), в (4) производится попытка закрыть полученный в конструкторе `AutoCloseable`.
3. `PrintingAutoCloseable` (5) - `AutoCloseable`, который печатает сообщения о своём создании (6) и закрытии (7).

В результате выполнения этой программы вывод будет примерно следующим:

```text
PrintingAutoCloseable created
Exception in thread "main" java.lang.IllegalStateException: I always throw
    at ru.misc.Main$ThrowingAutoCloseable.<init>(Main.java:19)
    at ru.misc.Main.main(Main.java:9)
```

Как видно, `PrintingAutoCloseable` закрыт не был!

---

**Вопрос:**

В каком порядке закрываются ресурсы, объявленные в try-with-resources?

**Ответ:**

В обратном.

Пример:

```java
public class Main {
    public static void main(String[] args) throws Exception {
        try (PrintingAutoCloseable printingAutoCloseable1 = new PrintingAutoCloseable("1");
             PrintingAutoCloseable printingAutoCloseable2 = new PrintingAutoCloseable("2");
             PrintingAutoCloseable printingAutoCloseable3 = new PrintingAutoCloseable("3")) {
        }
    }

    private static class PrintingAutoCloseable implements AutoCloseable {
        private final String id;

        public PrintingAutoCloseable(String id) {
            this.id = id;
        }

        @Override
        public void close() {
            System.out.println("Closed " + id);
        }
    }
}
```

Вывод:

```text
Closed 3
Closed 2
Closed 1
```

---

### Общие советы

#### Избегайте генерации исключений, если их можно избежать простой проверкой

Как уже было сказано выше, исключения ломают поток выполнения программы. Если же на сгенерированное исключение не найдется обработчика, не будет подходящего `catch` блока, то программа и вовсе будет завершена. Кроме того, генерация исключения это довольно дорогостоящая операция.

Помните, что если исключение можно не допустить, то лучше так и сделать.

Отсюда следует первый совет: **не брезгуйте дополнительными проверками**.

1. Не ловите `IllegalArgumentException`, `NullPointerException`, `ArrayIndexOutOfBoundsException` и подобные.
    Потому что эти ошибки - это явная отсылка к тому, что где-то недостает проверки.
    Обращение по индексу за пределами массива, `NullPointerException`, все эти исключения - это ошибка разработчика.
2. Вводите дополнительные проверки на данные, дабы избежать возникновения непроверяемых исключения

Например, запретите вводить в поле возраста не числовые значения, проверяйте ссылки на `null` перед обращением и т.д.

#### Предпочитайте `Optional`, если отсутствие значения - не исключительная ситуация

При написании `API` к каким-то хранилищам или коллекциям очень часто на отсутствие элемента генерируется исключение, как например в разделе [собственные исключения](#Собственные-исключения).

```java
class Catalog {
    Person findPerson(String name);
}
```

Но и в этом случае генерации исключения можно избежать, если воспользоваться `java.util.Optional`:

```java
Optional<Person> findPerson(String name);
```

Класс `java.util.Optional` был добавлен в `Java 8` и предназначен как раз для подобных ситуаций, когда возвращаемого значения может не быть. В зависимости от задачи и контекста можно как генерировать исключение, как это сделано в примере с `PersonNotFoundException`, так и изменить сигнатуру метода, воспользовавшись `java.util.Optional`.

Отсюда следует второй совет: думайте над `API` ваших классов, исключений можно избежать воспользовавшись другим подходом.

#### Заранее обдумывайте контракты методов

Важным моментом, который нельзя не упомянуть, является то, что если в методе объявляется, что он может сгенерировать исключение (с помощью `throws`), то при переопределении такого метода нельзя указать более общее исключение в качестве выбрасываемого.

```java
class Person {
    void hello() throws RuntimeException {
        // some code
    }
}

// Compile Error
class PPerson extends Person {
    @Override
    void hello() throws Exception {
        // some code
    }
}
```

Если было явно указано, что метод может сгенерировать `java.lang.RuntimeException`, то нельзя объявить более общее бросаемое исключение при переопределении. Но можно указать потомка:

```java
// IllegalArgumentException - потомок RuntimeException!
class PPerson extends Person {
    @Override
    void hello() throws IllegalArgumentException {
        // some code
    }
}
```

Что, в целом логично.

Если объявляется, что метод может сгенерировать `java.lang.RuntimeException`, а он выбрасывает `java.io.IOException`, то это было бы как минимум странно.

Это объясняется и с помощью полимофризма. Пусть есть интерфейс, в котором объявлен метод, генерирующий исключение. Если полиморфно работать с объектом через общий интерфейс, то разработчик обязан обработать исключение, объявленное в интерфейсе, а если одна из реализаций интерфейса генерирует более общее исключение, то это нарушает полиморфизм. Поэтому такой код даже не скомпилируется.

При этом при переопределении можно вообще не объявлять бросаемые исключения, таким образом сообщив, что все проблемы будут решены в методе:

```java
class PPerson extends Person {
    @Override
    void hello() {
        // some code
    }
}
```

Отсюда следует третий совет: необходимо думать о тех исключениях, которые делегирует метод, если класс может участвовать в наследовании.

#### Предпочитайте исключения кодам ошибок и `boolean` флагам-признакам успеха

1. Исключения более информативны: они позволяют передать сообщение с описанием ошибки
2. Исключение _практически_ невозможно проигнорировать
3. Исключение может быть обработано кодом, находящимся выше по стеку, а `boolean`-флаг или код ошибки необходимо обрабатывать здесь и сейчас

## Исключения и статические блоки

Еще интересно поговорить про то, что происходит, если исключение возникает в статическом блоке.

Так вот, такие исключения оборачиваются в `java.lang.ExceptionInInitializerError`:

```java
public class ExceptionHandling {
    static {
        throwRuntimeException();
    }

    private static void throwRuntimeException()  {
        throw new NullPointerException();
    }

    public static void main(String[] args)  {
        System.out.println("Hello World");
    }
}
```

Результатом будет падение со следующим стектрейсом:

```java
java.lang.ExceptionInInitializerError Caused by: java.lang.NullPointerException at exception.test.ExceptionHandling.throwRuntimeException(ExceptionHandling.java:13) at exception.test.ExceptionHandling. (ExceptionHandling.java:8)
```

## Многопоточность и исключения

Код в `Java` потоке выполняется в методе со следующей сигнатурой:

```java
public void run();
```

Что делает невозможным пробрасывание проверяемых исключений, т.е разработчик **должен** обрабатывать все проверяемые исключения внутри метода `run`.

Непроверяемые исключения обрабатывать необязательно, однако необработанное исключение, выброшенное из `run`, завершит работу потока.

Например:

```java
public class ExceptionHandling4 {
  public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread() {
        @Override
        public void run() {
                throw new RuntimeException("Testing unhandled exception processing.");
         }
    };
    t.start();
  }
}
```

Результатом выполнения этого кода будет то, что возникшее исключение прервет поток исполнения (interrupt thread):

```java
Exception in thread “Thread-0” java.lang.RuntimeException: Testing unhandled exception processing. at exception.test. ExceptionHandling4$1.run(ExceptionHandling4.java:27)
```

При использовании нескольких потоков бывают ситуации, когда надо знать, как поток завершился, из-за какого именно исключения. И, разумеется, отреагировать на это.

В таких ситуациях рекомендуется использовать `Thread.UncaughtExceptionHandler`.

```java
t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
          public void uncaughtException(Thread t, Throwable e)   {
             System.out.println("Handled uncaught exception in thread :" + t + " Exception : " + e);
         }
  });
```

И вывод уже будет:

```java
Handled uncaught exception in thread :Thread[Thread-0,5,main] Exception : java.lang.RuntimeException: Testing unhandled exception processing.
```

Необработанное исключение `RuntimeException("Testing unhandled exception processing.")`, убившее поток, было перехвачено специальным зарегистрированным обработчиком.

## Проверяемые исключения и их необходимость

В большинстве языков программирования, таких как `C#`, `Scala`, `Groovy`, `Python` и т.д., нет такого разделения, как в `Java`, на проверяемые и непроверяемые исключения.
Почему оно введено в `Java` было разобрано выше, а вот почему проверяемые исключения недолюбливают разработчики?

Основных причин две, это причины с: версионированием и масштабируемостью.

Представим, что вы, как разработчик библиотеки, объявили некоторый условный метод `foo`, бросающий исключения `A`, `B` и `C`:

```java
void foo() throws A, B, C;
```

В следующей версии библиотеки в метод `foo` добавили функциональности и теперь он бросает еще новое исключение `D`:

```java
void foo() throws A, B, C, D;
```

В таком случае новая версия библиотеки сломает код тех, кто ей пользуется. Это сравнимо с тем, что добавляется новый метод в интерфейс.

И с одной стороны, это правильно, так как в новой версии добавляется еще одно исключение и те, кто использует библиотеку должны отреагировать на все новые исключения. С другой стороны, чаще всего такие исключения будут также проброшены дальше. Все дело в том, что случаев, когда можно обработать специфический тип исключения, например тот же `D` или `A` в примере выше, и сделать в обработчике что-то интеллектуальное, можно пересчитать по пальцам одной руки.

Проблема с масштабируемостью начинается тогда, когда происходит вызов не одного, а нескольких `API`, каждый из которых также несет с собой проверяемые исключения. Представьте, что помимо `foo`, бросающего `A`, `B`, `C` и `D`, в методе `hello` вызывается еще и `bar`, который также бросает `E` и `T` исключения. Как сказано выше, как реагировать чаще всего непонятно, поэтому эти исключения делегируются вызывающему коду, из-за чего объявление метода `hello` выглядит совсем уж угрожающе:

```java
void hello() throws A, B, C, D, E, T {
    try {
        foo();
        bar();
    } finally {
        // clear resources if needed
    }
}
```

Все это настолько раздражающе, что чаще всего разработчики просто объявляют наиболее общее исключение в `throws`:

```java
void hello() throws Exception {
    try {
        foo();
        bar();
    } finally {
        // clear resources if needed
    }
}
```

А в таком случае это все равно, что сказать "метод может выбросить исключение" - это настолько общие и абстрактные слова, что смысла в `throws Exception` практически нет.

Также есть еще одна проблема с проверяемыми исключениями. Это то, что с проверяемыми исключениями крайне неудобно работать в `lambda`-ах и `stream`-ах:

```java
// compilation error
    Lists.newArrayList("a", "asg").stream().map(e -> {throw new Exception();});
```

Так как с `Java 8` использование `lambda` и `stream`-ов распространенная практика, то накладываемые ограничения вызовут дополнительные трудности при использовании проверяемых исключений.

Поэтому многие разработчики недолюбливают проверяемые исключения, например, оборачивая их в непроверяемые аналоги с помощью `re-throw`.

Мое мнение таково: на проверяемых исключениях очень хорошо учиться. Компилятор и язык сами подсказывают вам, что нельзя игнорировать исключения и требуют от вас реакции. Опять же, логическое разделение на проверяемые и непроверяемые помогает в понимании исключений, в понимании того, как и на что реагировать. В промышленной же разработке это становится уже больше раздражающим фактором.

В своей работе я стараюсь чаще использовать непроверяемые исключения, а проверяемые оборачивать в `unchecked` аналоги, как, например, `java.io.IOException` и `java.io.UncheckedIOException`.

## Заключение

Иерархия исключений в `Java`.

![Exception Hierarchy](../images/exception/exceptions.png)

Исключения делятся на два типа: непроверяемые(`unchecked`) и проверяемые(`checked`). Проверяемые исключения - это исключения, которые проверяются на этапе компиляции, мы **обязаны** на них отреагировать.

Проверяемые исключения в `Java` используются тогда, когда разработчик никак не может предотвратить их возникновение. Причину возникновения `java.lang.RuntimeException` можно проверить и устранить заранее, например, проверить ссылку на `null` перед вызовом метода, на объекте по ссылке. А вот с причинами проверяемых исключений так сделать не получится, так как ошибка при чтении файла может возникнуть непосредственно в момент чтения, потому что другая программа его удалила. Соответственно, при чтении файла требуется обрабатывать `java.io.IOException`, который является потомком `java.lang.Exception`.

Допускается создание собственных исключений, признак проверяемости или непроверяемости наследуется от родителя. Исключения - это такие же классы, со своим поведением и состоянием, поэтому при наследовании вполне допускается добавить дополнительное поведение или свойства классу.

Обработка исключений происходит с помощью конструкции `try/catch/finally`. Один блок `try` может иметь несколько `catch` блоков. В таком случае будет выполняться первый подходящий блок.

Помните, что `try` блок **не транзакционен**, все ресурсы, занятые в `try` **ДО** исключения остаются в памяти. Их надо освобождать и очищать вручную.
Если вы используете `Java` версии 7 и выше, то отдавайте предпочтение конструкции `try-with-resources`.

Основное правило:

> На исключения можно реагировать, их обработку можно делегировать, но ни в коем случае нельзя их игнорировать.

Определить когда надо реагировать, а когда делегировать проще простого. Задайте вопрос: "Знаю ли я как реагировать на это исключение?".
Если ответ "да, знаю", то реагируйте, пишите обработчик и код, отвечающий за эту реакцию, если не знаете что делать с исключением, то **делегируйте** вызывающему коду.

Помните, что перехват `java.lang.Error` стоит делать только если вы точно знаете, что делаете. Восстановление после таких ошибок не всегда возможно и почти всегда нетривиально.
Не забывайте, что большинство ошибок `java.lang.RuntimeException` и его потомков можно избежать.

Не бойтесь создавать собственные исключения, так как это позволит писать более гибкие обработчики, а значит более точно реагировать на проблемы.

> Представьте себе, что существуют пять причин, по которым может быть выброшено исключение, и во всех пяти случаях бросается `java.lang.Exception`. Вы же спятите разбираться, чем именно это исключение вызвано.
>
> (c) Евгений Матюшкин.

Помните, что исключения ломают поток выполнения программы, поэтому чем раньше вы обработаете возникшую проблему, тем лучше. Отсюда же следует совет, что лучше не разбрасываться исключениями, так как помимо того, что это ломает поток выполнения, это еще и дорогостоящая операция.

Постарайтесь не создавать 'универсальных' обработчиков, так как это чревато трудноуловимыми ошибками.

Если исключение можно не генерировать, то лучше так и сделать. Не пренебрегайте проверками.

Старайтесь продумывать то, как вы будете реагировать на исключения, не игнорировать их, использовать **только** `try-с-ресурсами`.

Помните:

> In Java you can ignore exceptions, but you have to willfully do it. You can't accidentally say, "I don't care." You have to explicitly say, "I don't care."
>
> (c) James Gosling.

Для закрепления материала рекомендую ознакомиться с ссылками ниже и [этим](./questions.md) материалом.

## Полезные ссылки

1. [Книга С. Стелтинг 'Java без сбоев: обработка исключений, тестирование, отладка'](https://www.ozon.ru/context/detail/id/2342758/)
2. [Oracle Java Tutorials](https://docs.oracle.com/javase/tutorial/essential/exceptions/index.html)
3. [Лекция Технострим Исключения](https://www.youtube.com/watch?v=zRRopPImRqA)
4. [Лекция OTUS Исключения в Java](https://www.youtube.com/watch?v=nP-yT6tmbGs)
5. [Лекция Ивана Пономарёва по исключениям](https://www.youtube.com/watch?v=YgY2pksf3k8&list=PL4_hYwCyhAvblhTbPQmOF4b3kilWSpOjU&index=4)
6. [Заметка Евгения Матюшкина про Исключения](http://www.skipy.ru/technics/exceptions.html)
7. [Failure and Exceptions by James Gosling](https://www.artima.com/intv/solid.html)
8. [The Trouble with Checked Exceptions by Bill Venners with Bruce Eckel](https://www.artima.com/intv/handcuffs.html)
9. [Никто не умеет обрабатывать ошибки](https://habr.com/ru/post/221723/)
10. [Исключения и обобщенные типы в Java](https://youtu.be/fH6G8KrjElk)
11. [Вопросы для закрепления](./questions.md)
