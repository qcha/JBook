###Введение
При написании приложения возникают некоторые нештатные, нестандартные ситуации.
Например:
* Оборвался коннект с БД
* Пользователь ввел некорректыне данные
* Не можем закрыть файл
* Не хватает памяти
* и т.д

Что же с ними делать?
Такие ситуации можно либо игнорировать, либо как-то реагировать.

Мы можем возвращать некий код ошибки, а после уже расшифровывать(интерпритировать) его. Но такой способ неудобен, так как слишком немногословен, требует помнить коды-ошибок(либо постоянно сверятся с документацией),  а также не позволяет удобно обрабатывать такие ситуации. Поэтому в Java используется механизм Exceptions.

В Java механизм Exception - построен на классах, которые хранят в себе некие данные о нестандартной ситуации - причину, сообщение и т.д

Рассмотрим механизм исключений в Java подробнее.

#### Иерархия исключений

Ниже мы видим иерархию исключений, корень - `java.lang.Throwable` и два класса - `java.lang.Exception` и `java.lang.Error`, это два главных класса.
`java.lang.Exception` - это super class для `java.lang.RuntimeException`.

![](../images/exceptions.png)

*Картинка большая, чтобы вы навсегда запомнили ее.*

Понятно, что раз мы работаем с классами, то мы можем наследоваться от этих классов и создавать собственные исключения.
Надо понимать, что Exceptions - это тоже классы, т.е мы туда можем положить свою логику, методы и переменные, если надо. Однако кидать исключения - довольно дорогая операция, поэтому не надо просто так разбрасываться ими.

В Java исключения делятся на два типа. Это так называемые checked и unchecked - проверяемые и непроверяемые исключения. Ниже рассмотрим подробнее их.
Как мы видим по схеме `java.lang.Throwable` и `java.lang.Exception` - это checked exceptions, `java.lang.RuntimeException` и `java.lang.Error` - это unchecked.

Runtime Exceptions - это исключения времени выполнения
Checked exceptions проверяются компилятором в Сompile Time. И их мы обязаны обработать. В то время как RE(Runtime Exceptions) мы не обязаны явно перехватывать и обрабатывать, ну на то они и runtime:)

Мы также можем перехватывать исключения. И перехватывать мы можем все виды исключений.

Но тогда зачем нам столько видов исключений?

### Exceptions

* java.lang.Exception
Это ситуации, которые нам не подконтрольны, т.е не смогли закрыть файл, не смогли дессериализовать класс - мы ничего не можем сделать, но можем отреагировать.
Опять же мы обязаны такие исключения обрабатывать. Либо прокидывать вверх с помощью throws, в сигнатуру метода. Метод может декларировать сколько угодно исключений.

* java.lang.RuntimeException
А вот тут уже - это наши ошибки, ошибки разработчика скорее. Т.е обращаемся к null, делим на ноль где-то и прочее.
Мы можем эти ошибки перехватывать, а можем пропускать. Ловить такие ошибки постоянно - не совсем правильно наверное, так как мы можем так и не понять причину ошибок и падений.

* java.lang.Error
Критические ошибки, после которых мы не можем или с трудом можем продолжать работу.
Как и все остальные - мы можем такие ошибки ловить, но зачем? Ловить их можно только в случае, если мы можем или знаем как нам поступить в таких ситуациях.

Кидать мы можем тоже любые исключения.

### Error vs Exception
Error - это более серьезная ситуация, нежели Exception. Т.е если происходит что-то такое, что мы либо не можем исправить, либо это крайне сложно починить, например, у нас закончилась память или мы вызываем несуществующий метод - это вот `Error`. Т.е непросто исключительная ситуация - а прямо рядом с паникой:)
Но если мы не можем закрыть файл, мы делаем какой-нибудь запрос, не можем строку к число преобразовать - это ситуации, после которых мы **можем** продолжить работать, мы можем перехватить это, обработать(например - попросить пользователя ввести еще раз число) - это `java.lang.Exception`.

Т.е разница - в *логическом разделении*.

### Обработка
//todo написать про throws
Ловить и обрабатывать ошибки - try/catch/finally. Тут на первый взгляд все просто - все что *может* дать нам нестандартную ситуацию - оборачиваем в try,  в блоке catch перечисляем то, что мы ждем, т.е какие исключения мы понимаем, что будут тут.
После чего работаем в блоке finally.

Сразу надо сказать, что try-catch блок - **не транзакционный**, т.е мы создаем объекты в try, работаем и тут хоп! - ошибка, так вот объекты так и останутся в памяти, если мы их не почистим в finally или catch блоке.

По сути именно поэтому и существует finally - туда мы зайдем **в любом** случае. Это важный момент!

Также, мы не можем работать с объектами из try блока в других блоках - почему? Потому что компилятор не может нам гарантировать, что эти объекты создались, а вдруг у вас там кинулся Exception? Тогда после исключения строчки кода не выполняются и объекты мы не создали, а значит и работать с ними не можем.

Еще один момент, это так называемый re-throw.
Это когда вы перехватываете exception в catch-block, формируете там еще один и выбрасываете уже его, возможно(почти обязательно) вкладывая предыдущий в этот.
Т.е:
```java
try {
Reader readerConf = ....
readerConf.readConfig();
} catch(IOException ex) {
//logging error
throw new ComponentException(ex)
}
```
Что мы сделали?Мы перехватили ошибку чтения, обернули ее в новую ошибку и выкинули наверх. Для чего это нужно? Это полезно для гибкой обработки ошибок, т.е неважно что стало с нашим конфигом(нет файла, нет какой-то строки) - мы формируем ошибку, что мы не можем работать с этим компонентом программы.

Часто бывает полезно перехватить checked-исключение, залогировать его и выкинуть уже unchecked.
Т.е вы понимате, что данный exception критический, вы его логируете и кидаете уже необрабатываемое исключение дальше.

##### Catch блок
Расположение catch blocks - важно.
Пусть у нас метод бросает IOException и Exception, мы пишем что-то типа такого:
```java
try {
method();
} catch (Exception e) {//do some logic 1}
catch (IOException e) {//do some logic 2}
```

И видим, что обработка IOException недостижима, так как мы более широкий фильтр "отлова" установили выше.

Это похоже на то, как мы используем сито. Есть более широкие, есть уже. Так вот, если установить выше всех узкое сито - до низу почти ничего не дойдет, ведь мы все перехватим выше. Принцип ясен.

Отсюда понятно, что если нам надо перехватить прямо вот **все**, то надо ловить Throwable:
```java
try {
method();
} catch (Throwable t) {//do some logic 1}
```

Отметим, что в таком подходе мы ловим и RE, и Error!

Ловим RE:
```java
try {
   String numberAsString = "one";
   Double res = Double.valueOf(numberAsString);
    } catch (RuntimeException re) {
            System.out.println("Error while convert string to double!");
    }
```

Ловим Error:

```java
        try {
            throw new Error();
        } catch (RuntimeException re) {
            System.out.println("RE");
        } catch (Error error) {
            System.out.println("ERROR");
        }
    }
```
В целом - что мы ставим в catch - все, что ниже по иерархии мы и ловим.
Соответственно надо понимать, что чем шире вы поставите свой *фильтр* - тем больше вы поймате исключений, поэтмоу надо задумываться - а надо ли вам ловить что-то конкретно или общее?

Небольшой тест:

```java
public static void main(String[] args){
        try {
            try {
                throw new Exception("0");
            } finally {
                if (true) {
                    throw new IOException("1");
                }
                System.err.println("2");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("3");
            System.err.println(ex.getMessage());
        }
    }
```

Видим на выходе "1"!

Аккуратнее с обработкой исключений.

##### Свои исключения
Полезно иногда иметь свою иерархию Exceptions. Например, у нас есть method2() и он кидает 3 разных Exception-а.
Имея свою иерархию(т.е три исключения, отнаследованных от Exception) - мы просто пишем 3 catch block-а на каждое исключение и обрабатываем каждую ситуацию как надо.
Без этого у нас был бы только один catch block с перехватом Exception, где мы уже будем понимать что мы вообще перехватили и как это обрабатывать.


##### Исключения и потоки
А что если наше исключение прерывает поток(interrupt thread) - все просто используем `Thread.UncaughtExceptionHandler`.

##### Исключения и наследование
Однако сазу надо сказать, что хоть вы и *можете* наследоваться от Throwable, однако это крайне не рекомендуется.
//todo
Переопределяющий метод не должен бросать новое или более широкое исключение, однако он может ВООБЩЕ не бросать исключение!


####Вывод
* Используем обрабатываемые исключения в случае, когда мы понимаем, что тут может быть ошибка.
* Не обрабатываемое исключение - если это наша ошибка.
* Полезно иметь свою иерархию исключений.
* Используйте finally, если работаете с ресурсами и try-with-resources
* finally блок отрабатывает всегда.
* Кидаем исключения с помощью `throw`
* Поднять исключение выше -  `throws`
* Все проверяемые исключения обязаны быть отловлены!
* try-catch block **не транзакционный** - все объекты, которые создали в try *ДО* исключения остаются в памяти.
