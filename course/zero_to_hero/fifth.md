# Java Базовый Курс

## Занятие 5

Пятое занятие в рамках `Java` курса.

В [прошлый раз](./fourth.md) мы затронули следующие темы:

* Исключения
* Правила реагирования на исключения

В рамках этого занятия мы обсудим такую тему как коллекции в `Java`. Какие коллекции существуют в `Java`, какие операции с ними возможны, когда что использовать и т.д.

## Введение

В начале проведем некоторую проверку знаний по прошлому материалу.

[Проверочная работа](../exceptions/questions.md).

## Коллекции

Коллекции в `Java` - это динамические структуры данных для хранения объектов. Для того, чтобы понять зачем понадобились коллекции, если есть массивы, то давайте вспомним, какие ограничения задаются обычным массивом?

Предположим, вам нужен массив строк, в котором планируется хранить около 10-ти элементов:

```java
String[] array = new String[10];
```

Вас все устраивает до тех пор, пока не понадобится добавить 11-й элемент в такой массив. Придется создавать массив большего размера, переносить туда данные из старого и после этого уже добавлять 11-й элемент.

Каждый раз думать о таком копировании и увеличении размера крайне неудобно. Было бы комфортнее, если бы существовали структуры данных, расширяющиеся динамически.

Следующим примером представим, что вам потребовалась структура данных, не допускающая хранения дублей, множество. Зачастую необходима структура данных, хранящая пару ключ-значение. Каждый раз реализовывать такую структуру данных и отдельной библиотекой добавлять в проект не лучшая идея, хочется, чтобы такие вещи предоставлялись на уровне стандартной библиотеки. Так и появились коллекции в версии `Java 1.2`.

Подробнее про [коллекции](../collections/intro.md). Здесь важно ознакомиться с представленными коллекциями, а также детально рассмотреть [списки](../collections/list/intro.md) и [хеш-таблицы](../collections/map/intro.md).

Почему именно их?

Потому что это наиболее популярные структуры данных в `Java`, это основа. Их понимание даст и то, как в `Java` устроены очереди, и то, как устроены множества.

## Практика

### Список на базе массива

Напишите реализацию интерфейса:

```java
package ru.mipt.collections;
​
/**
 * Кастомная реализация списка
 */
public interface CustomList {
​
    /**
     * @return возвращет количество элементов в списке
     */
    int size();
​
    /**
     * @return возвращет true, если список пустой, и false в обратном случае
     */
    boolean isEmpty();
​
    /**
     * Проверяет содержит ли ваш список element
     *
     * @param element объект, наличие которого вы хотите проверить в вашем списке
     */
    boolean contains(Object element);
​
    /**
     * Добавляет элемент в список.
     *
     * @param element объект, который вы хотите добавить
     * @return возвращает true, если объект element добавлен
     */
    boolean add(Object element);
​
    /**
     * Удаляет объект
     * @param element объект, который вы хотите удалить
     * @return возвращает true, если объект element был удален, или false, если такого объекта не было в списке
     */
    boolean remove(Object element);
​
    /**
     * Проверяет полное совпадение вашего списка с другим списком
     *
     * @param  anotherCustomList список, который вы хотите сравнить с текущим
     * @return true, если ваш список содержит anotherCustomList, и false в обратном случае
     */
    boolean containsAll(CustomList anotherCustomList);
​
    /**
     * Проверяет частичное совпадение вашего списка с другим списком. То есть проверяется содержит ли ваш список anotherCustomList, как подсписок.
     * Пример. Допустим у вас есть список int вида {44,39,72,51,14,55}, тогда если список anotherCustomList содержит в себе элементы {72,51,14}, то
     * значит, что ваш список содержит anotherCustomList, как подсписок
     *
     * @param  anotherCustomList список, который вы хотите сравнить с текущим
     * @return true, если ваш список содержит anotherCustomList, как подсписок, и false в обратном случае
     */
    boolean containsSublist(CustomList anotherCustomList);
​
    /**
     * Возврашает элемент по входному индексу
     *
     * @param  index индекс элемента, который вы хотите получить из своего списка. Если индекс, по которому вы хотите достать больше количества элементов,
     *               тогда возвращайте null
     * @return объект по заданному индексу или null
     */
    Object get(int index);
```

Реализация должна быть основана на массиве, наподобие `java.util.ArrayList`.
В случае, если массив, содержащий элементы в списке, переполнен, список должен динамически расишириться в 2 раза.

### Реализация на связном списке

Напишите еще одну реализацию интерфейса, представленного выше, но на базе связаного списка.

## Полезные ссылки

1. [Лекторий ФИВТ, Java (3 курс) - лектор Пономарёв. Java #7. Collections, lambdas, method references](https://www.youtube.com/watch?v=cNkZvnBARAc&list=PL4_hYwCyhAvblhTbPQmOF4b3kilWSpOjU&index=7)
2. [Разработка на Java (2018). Generics & collections | Технострим](https://www.youtube.com/watch?v=askCqwd_Xkw&list=PLrCZzMib1e9pnFbVV3u4s7ki5NTnm7WgT&index=3)