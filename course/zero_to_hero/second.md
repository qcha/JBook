# Java Базовый Курс

## Занятие 2

Второе занятие в рамках `Java` курса.

На [первом](./first.md) занятии были разобраны следующие темы:

* Почему `Java`?
* Типы данных в `Java`
* Циклы
* Условные операторы

В рамках этого занятия читатель ближе познакомится с классами и объектами, научится сам объявлять и оперировать ими.

## Класс и Объект

В прошлый раз для примера с выводом на экран "Hello World" нам уже понадобилось объявить свой класс:

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```

`Java` является объектно-ориентированным языком, поэтому такие понятия как "класс" и "объект" играют в нем ключевую роль. Любую программу на `Java` можно представить как набор взаимодействующих между собой объектов.

Класс - это как техническое описание прибора, купленного вами в электронном дискаунтере.
Он описывает то, какими свойствами должен обладать прибор: материал, цвет и т.д.
Эти свойства уникальны, ведь для каждого прибора они свои. Свойства объекта - это его `состояние`.

Кроме этого класс описывает еще и *поведение* объекта, то как с ним взаимодействовать. Поведение - это методы класса. Все объекты, являющиеся экземплярами одного и того же класса, ведут себя одинаково. Поведение объекта определяется методами, которые можно вызвать.

![](../images/oop/basic_concepts_drill.jpeg)

Объект - это уже непосредственно сам прибор, сделанный **по** техническому описанию, со своим уникальным набором свойств и описанным поведением.

> Самое лаконичное описание объекта предложил Буч:
>
> «Объект обладает состоянием, поведением и индивидуальностью».

В качестве примера опишем класс `Принтер`. Состояние - это цвет, марка, скорость печати. Поведение - печать, сканирование.

Обратите внимание на наименования.

```java
public class Printer {
    public String color;
    public String mark;
    public int printSpeed;

    void print() {
        System.out.println("Printing");
    }

    void scan() {
        System.out.println("Scan");
    }
}
```

Конструирование объекта на основе некоторого класса называется созданием экземпляра(instance) класса. Новый объект на основе класса создается с помощью ключевого слова `new`:

```java
Printer printer = new Printer();
```

Так как метод - это поведение *объекта*, то для вызова метода нужен объект.

```java
public class PrinterExample {
    public static void main(String[] args) {
        Printer printer = new Printer();
        printer.print();
    }
}
```

Как уже было сказано на прошлом занятии, классы относятся к ссылочным типам данных. Все, что находится справа от `=` - это объект, в то время как все, что находится слева - это **ссылка** на объект.

В программе, написанной по принципам `ООП`, отдельные компоненты рассматриваются как предметы из реального мира, такие как дом, дерево, кот, яблоко и т.д.

Теперь перепишем класс `Printer` так, чтобы при печати он выводил свои характеристики:

```java
public class Printer {
    public String color;
    public String mark;
    public int printSpeed;

    void print() {
        System.out.println("Color: " + color);
        System.out.println("Mark: " + mark);
        System.out.println("PrintSpeed: " + printSpeed);
    }

    void scan() {
        System.out.println("Scan");
    }
}
```

После чего создадим объект этого класса и вызовем на нем метод `print`.
Как вы думаете, какие значения цвета, марки и скорости печати у объекта?

На экран будет выведено:

```java
null
null
0
```

Объект класса `Printer` создали, но поля никак не инициализировали. Поэтому поля будут заполнены значениями по-умолчанию.
Так как цвет и марка - это ссылочные типы, то значения по-умолчанию для них `null`, в то время как скорость печати задана примитивным типом `int`, для которого значение по-умолчанию 0.

Исправим это:

```java
public class PrinterExample {
    public static void main(String[] args) {
        Printer printer = new Printer();
        printer.color = "Black";
        printer.mark = "HP";
        printer.printSpeed = 14;
        
        printer.print();
    }
}
```

Из примера ясно, что в принтере со значениями по-умолчанию смысла нет, а инициализация переменных так, как сделано выше, может привести к трудноуловимым ошибкам.  Представьте себе, что у вас в классе 6 или 10 полей? Вероятность опечатки повышается в несколько раз. При этом код будет комплироваться, но состояние объекта будет сформировано неверно. Отсюда следует, что нужна возможность передавать объекту необходимые значения прямо во время создания.

### Конструктор

Конструктор в `Java` играет непосредственную роль при создании и инициализации объекта.

Основное правило: конструктор обязан быть в каждом классе. Не бывает классов без конструкторов. 

Имя конструктора аналогично имени класса, а сам синтаксис схож с синтаксисом метода. Однако, конструктор - это не совсем метод.
Между конструкторами и другими методами есть существенная разница: конструктор можно вызывать только в сочетании с оператором `new`. Конструктор нельзя применить к существующему объекту, чтобы изменить информацию в его полях и у конструктора полностью отсутствует возвращаемое значение.

Пример конструктора без аргументов:

```java
public class Printer {
    // конструктор
    public Printer() {
        // тело конструктора
    }
}
```

Теперь доработаем наш класс `Printer`, создав конструктор, принимающий необходимые аргументы:

```java
public class Printer {
    public String color;
    public String mark;
    public int printSpeed;

    Printer(String color, String mark, int printSpeed) {
        this.color = color;
        this.mark = mark;
        this.printSpeed = printSpeed;
    }
}
```

Ключевое слово `this`(дословно переводится "этот") в данном случае -  это ссылка на объект из которого был вызван `this`. Здесь он используется для того, чтобы отличить поля объекта от параметров метода.

Так как был объявлен конструктор, принимающий три параметра, то старое создание объекта уже невозможно:

```java
Printer printer = new Printer(); // ошибка комплияции
Printer printer = new Printer("Black", "HP", 14); // возможно
```

Конструкторов может быть несколько:

```java
public class Printer {
    public String color;
    public String mark;
    public int printSpeed;

    Printer(String color, String mark, int printSpeed) {
        this.color = color;
        this.mark = mark;
        this.printSpeed = printSpeed;
    }

    Printer(String color, String mark) {
        this.color = color;
        this.mark = mark;
        this.printSpeed = 14;
    }
}
```

Стоит заметить, что в примере выше один конструктор отличается от другого только тем, что в одном значение `printSpeed` задается явно при инициализации.
Дабы избежать дублирования кода можно вызвать из одного конструктора другой:

```java
public class Printer {
    public String color;
    public String mark;
    public int printSpeed;

    Printer(String color, String mark, int printSpeed) {
        this.color = color;
        this.mark = mark;
        this.printSpeed = printSpeed;
    }

    Printer(String color, String mark) {
        this(color, mark, 14);
    }
}
```

Обратите внимание, что `this` со скобочками - это вызов конструктора.

---

**Вопрос**:

Как вы считаете, можно ли выполнить какие-то действия *ДО* вызова другого конструктора через `this`?

```java
public class Printer {
    public String color;
    public String mark;
    public int printSpeed;

    Printer(String color, String mark, int printSpeed) {
        this.color = color;
        this.mark = mark;
        this.printSpeed = printSpeed;
    }

    Printer(String color, String mark) {
        System.out.println("Действие ДО вызова через this конструктора Printer(String color, String mark, int printSpeed)");
        this(color, mark, 14);
    }
}
```

**Ответ**:

Нет, нельзя.
Вызов другого конструктора через `this` должен быть первым выражением в теле конструктора.

А вот после уже можно.

```java
    Printer(String color, String mark) {
        this(color, mark, 14);
        System.out.println("Действие ПОСЛЕ вызова через this конструктора Printer(String color, String mark, int printSpeed)");
    }
```

---

Если не объявить конструктор класса явно, то будет создан пустой конструктор по-умолчанию, поэтому конструкция типа:

```java
public class Hello {
}
```

Будет эквивалентна:

```java
public class Hello {
    public Hello() {
    }
}
```

---

**Вопрос**:

Мы уже поняли, что если не объявить конструктор самому, то `Java` сделает нам конструктор по-умолчанию. А если я все-таки объявлю свой собственный конструктор, будет ли у меня конструктор по умолчанию?

**Ответ**:

Нет, не будет.

Как только вы объявляете хотя бы один конструктор, то ответственность за работу с конструкторами, а значит и за то, как будут создаваться объекты этого класса, `Java` с себя снимает.

---

**Вопрос**:

Хорошо, а что если мне нужен и пустой конструктор, похожий на конструктор по умолчанию, и еще парочка конструкторов, принимающих значения в качестве аргументов?

**Ответ**:

В таком случае, вам следует явно объявить каждый конструктор, который вам нужен.

---

## ООП

Читаем об этом [здесь](../oop/intro.md).

После того, как вы прочли материалы выше, мы можем продолжить.

Для закрепления попробуйте ответить на вопросы:

* Зачем нужен `private` конструктор у класса?
* Что значит отношение `is a`? А `has a`?
* Что такое `пакет`?
* Существует ли в `Java` ввозможность множественного наследования?
* В чем смысл `инкапсуляции`?
* Приведите пример использования `наследования`?

## Ключевое слово final

После того, как читатель познакомился с наследованием необходимо также рассказать еще и про то, как можно запретить наследоваться от своих классов и для чего это надо.

Для этого в `Java` есть ключевое слово [final](../start/final.md)

## Практика

Сразу стоит сказать, что эти задачи довольно просты и направлены только на то, чтобы вы ближе познакомились с синтаксисом и привыкли к нему.

### Выстраивание иерархии

Опишите класс `Student`, у которого есть возраст, имя, принадлежность к ВУЗу.
Опишите также класс `Person`, у которого есть возраст и имя.
Опишите класс `Employee`, у которого есть возраст, имя, зарплата и наименование ВУЗа, который он закончил.

Попробуйте связать все три класса в иерархию, вспомните про инкапсуляцию данных, постарайтесь избежать дублирования кода.

### Электронная библиотека

Напишите класс, представляющий книжную библиотеку. Библиотека внутри хранит массив книг, книгу можно получить и вернуть, можно запросить список всех книг библиотеки.

У Книги есть идентификатор, название, автор(ы).

> При этом не забудьте про [правильное оформление](../start/code_style.md) вашего кода.

## Чего стоит опасаться

Остерегайтесь опасной практики, когда один класс становится ответственен за слишком большое количество задач.
Это проявляется в том, что зачастую начинающие разработчики объявляют у класса большое количество методов и атрибутов, которые не относятся к классу.
Например, класс `MailSender`, ответственный за рассылку писем, становится ответственен еще и за проверку, за добавление или удаление заголовков у рассылаемых писем.

Такой код будет работать, но это плохая практика. Старайтесь разносить разные области ответственности по разным классам.
Пусть `MailSender` будет ответственен только за рассылку писем, а за проверку будет ответственен другой класс, также как и за добавление/удаление заголовков.

Старайтесь думать над тем, как разбить вашу большую задачу на составляющие.
Выделяйте области ответственности и **делегируйте** их разным классам.

## Полезные ссылки

1. [014. Языки программирования - Сергей Крыжановский](https://www.youtube.com/watch?v=zxlE4rsZTME)
2. [Лекторий ФИВТ, Java (3 курс) - лектор Пономарёв. Java #3. Классы](https://www.youtube.com/watch?v=BC7OWimiVoo&list=PL4_hYwCyhAvblhTbPQmOF4b3kilWSpOjU&index=3)
3. [Ключевое слово this](https://www.examclouds.com/ru/java/java-core-russian/keyword-this)
4. [Ключевые слова this и super](../oop/this_super.md)