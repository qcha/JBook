# Java Базовый Курс

## Занятие 3

Третье занятие в рамках `Java` курса.

В [прошлый раз](./second.md) мы затронули следующие темы:

* Инкапсуляция
* Абстракция
* Наследование
* Полиморфизм

В рамках этого занятия мы поговорим про `java.lang.Object`, абстрактные классы и интерфейсы, их различия и необходимость применения.

## Введение

В начале проведем проверку знаний по прошлому материалу.

---

**Вопрос**:

Наследование.

Когда его стоит применять?

Что значит отношение `is a`? А `has a`?

Существует ли в `Java` множественное наследование?

**Ответ**:

`Наследование` — это инструмент, позволяющий описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.
Это мощный инструмент переиспользования кода и создания собственных иерархий.

Общая идея наследования - это выстраивать иерархию классов, идя от чего-то абстрактного к чему-то более конкретному.

Наследование имеет смысл применять, если связь между двумя классами можно описать как `is a`.
В противном случае, лучше задуматься о композиции/агрегации, описывающей связь как `has a`.

Множественного наследования в `Java` нет.

---

**Вопрос**:

Инкапсуляция.

Расположите модификаторы доступа в порядке убывания области видимости.

Как влияют модификаторы доступа на поля классов, участвующих в наследовании?

**Ответ**:

`Инкапсуляция` - механизм, позволяющий объединить данные и методы, работающие с этими данными, в единый объект и скрыть детали реализации от пользователя.

| Модификатор доступа | В классе | В пакете | В наследнике(вне пакета) | Везде |
|:-------------------:|:--------:|:--------:|:------------------------:|:-----:|
|        public       |     +    |     +    |             +            |   +   |
|      protected      |     +    |     +    |             +            |   -   |
|       package       |     +    |     +    |             -            |   -   |
|       private       |     +    |     -    |             -            |   -   |

---

## Интерфейс

Как мы уже обсуждали во [введении в ООП](./intro.md), класс - это совокупность `поведения` и `состояния`.

Состояние - это то, какую информацию, какие данные хранит этот класс.
Поведение же - это то, что мы можем ожидать при работе с классом, как с ним взаимодействовать и т.д.

В `ООП` понятию `поведение` выделена настолько большая роль, что существует специальный термин для этого - `интерфейс`.

`Интерфейс` - это определение функциональности, в виде определния методов и свойств, без каких либо привязок к особенностям класса.

Читаем об этом [здесь](../oop/interface.md)

## Абстрактный класс

Снова вспоминаем, что класс - это совокупность `поведения` и `состояния`.

Назовем класс полностью определенным, если его поведение(интерфейс) реализовано, т.е мы точно знаем **что** умеет делать объект класса и **как** он это делает, такой класс **полностью** реализует свой интерфейс.
И, что самое главное, такой класс **конкретен**.

Однако, бывают ситуации, когда мы можем описать класс, но определение его поведения **не завершено**. Мы знаем **что** умеет делать класс, но еще не определили **как именно** он это делает.

Возьмем любимый пример всех учебников по программированию для начинающих: класс `Figure`, фигура.

Фигура - это нечто асбтрактное, когда говорят фигура мы не можем представить ничего конкретного.
Фигурой может быть и квадрат, и круг, и прямоугольник.

Каждая фигура состоит из линий, углов, имеет цвет.
Также у фигуры может быть метод `draw` - рисующий фигуру.

Мы описали метод `draw` у фигуры, дали имя, определили аргументы, возвращаемый тип, но не реализовали тело метода, так как каждую фигуру рисуют по-своему, т.е реализация каждой фигуры разная и она определена непосредственно у потомков этого класса.

Точно то же самое можно сказать и про любимца последних заметок по `ООП` - класс `Person`.

При этом каждый `Person` имеет состояние: имя, возраст, рост и т.д.
И также `Person` имеет еще и поведение: ходить, спать и т.д.

Однако он не имеет главного - он не конкретен, при этом он обладает и `поведением`, и `состоянием`.

В таком случае мы говорим, что такой класс абстрактен. Он **не завершен**.

Читаем об этом [здесь](../oop/abstract_class.md)

## Различия

Различия между двумя этими понятиями следуют из определения. Интерфейс не обладает состоянием, в отличии от абстрактного класса. А раз что-то может иметь состояние, то должен быть механизм для инициализации этого состояния - конструктор. Понятно, что интерфейс конструктор иметь не может.

Абстрактный класс должен участовать в **наследовании**, а значит должен отвечать `is a` типу отношения. В то время как `интерфейс` реализуется, он **добавляет** поведение классу, соответственно единственный вопрос, который вы должны задать: должен ли уметь ваш класс делать то, что добавляет интерфейс?

Все методы `интерфейса` по-умолчанию являются `public abstract` методами.
Все поля у `интерфейса` являются `public static final` - т.е являются константами.

В то время как у `абстрактного класса` мы можем воспользоваться и другими модификаторами доступа, в частности, скрыть какие-то методы или поля.
Поля у `абстрактного класса` не обязательно(да и не желательно) делать константами.

Читаем об этом [здесь](../oop/abstract_vs_interface.md)

## java.lang.Object

`java.lang.Object` - это корень иерархии всех классов в `Java`.
Это значит, что каждый класс, **включая массивы**, является потомком `java.lang.Object`.

А так как все классы в `Java` являются потомками `java.lang.Object`, то все эти методы унаследованы каждым классом в `Java`. Именно поэтому важно представлять о чем они и какие возможности предоставляют.

Читаем про [java.lang.Object](../object/intro.md).

## Практика

### Список

Объявите интерфейс, который описывает структуру данных список. Подумайте, какие методы туда можно внести?

### Покер

Для практики можно написать простейшую реализацию игры в покер.

Объявите класс `Карта`(должен ли он быть абстрактным?), этот класс имеет масть и вес, например, шестерка пик или десятка червей.

Объявите класс, который будет отвечать за выигрышные комбинации карт.
Например, пара одной масти, тройка, пять карт в ряд и т.д.

Колода - это массив(список?) из N разных карт.
Колоду можно перемешивать.

Игрок получает в начале 5 карт, случайным образом.

После первого хода каждый игрок может сбросить от 0 до 5 карт и взамен сброшенных взять из колоды новые карты.

После чего каждый по очереди выкладывает карты на стол, а класс-крупье определяет победителя с лучшей комбинацией.

## Полезные ссылки

1. [Лекторий ФИВТ, Java (3 курс) - лектор Пономарёв. Java #3. Классы](https://www.youtube.com/watch?v=BC7OWimiVoo&list=PL4_hYwCyhAvblhTbPQmOF4b3kilWSpOjU&index=3)
2. [Абстрактный класс в ООП](https://www.youtube.com/watch?v=jq-UlNmHYAQ)
3. [Интерфейс в ООП](https://www.youtube.com/watch?v=cGCLDYqH7Pw)
