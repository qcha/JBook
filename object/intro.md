# java.lang.Object и все-все-все

## Введение

`Java` - это объектно-ориентированный язык программирования.
В ООП мы в основном оперируем понятиями класса и объекта.

Подробнее про ООП можно прочесть [здесь](../oop/intro.md).

Ну а если вы ознакомились с основными понятиями, то давайте обсудим главный класс в `Java`.
И этим классом является: `java.lang.Object` - это корень иерархии всех классов в `Java`.

Это значит, что каждый класс, **включая массивы**, является потомком `java.lang.Object`.

Именно поэтому писать что-то в духе:

```java
public class Test extends Object {
    // some code
}
```

Абсолютно лишено смысла, `Java` автоматически добавит ваш класс в иерархию с родителем `java.lang.Object`.

При этом, даже если вы не создали ни одного конструктора для вашего класса, то `Java` создаст конструктор по умолчанию.
И, с учетом того, что у нас есть родительский класс, этот конструктор будет выглядеть в виде:

```java
public class Test {
    public Test() {
        super();
    }
}
```

Теперь давайте посмотрим какое влияние на поведение классов оказывает `java.lang.Object`, являясь родительским классом.
Поведение класса - это его интерфейс, методы, которые он предоставляет.

## Методы java.lang.Object

Всего в `java.lang.Object` представлено 11 `public`-методов, 6 из которых имеют нативную реализацию. Так как все классы в `Java` являются потомками `java.lang.Object`, то все эти методы унаследованы каждым классом в `Java`. Именно поэтому важно представлять о чем они и какие возможности предоставляют.

> Нативная реализация означает, что метод реализован в платформенно-зависимом коде, чаще всего на `C/C++`, и скомпонован в виде динамической библиотеки.
> А значит, эта реализация зависит от `JVM`.
>
> Возможно, вас сейчас это напугало, но на самом деле достаточно просто понимать, что `native` означает лишь то, что мы вызываем код, который реализован не на `Java`.

* [toString](./toString.md)
* [clone](./clone.md)
* [hashCode](./hashcode.md)
* [equals](./equals.md)
* [finalize](./finalize.md)
* [getClass](./getClass.md)
* `wait(long timeout)`
* `notify()`
* `notifyAll()`

## Почему java.lang.Object не является абстрактным классом

После того, как мы ознакомились с методами `java.lang.Object`, прочли про `ООП`, то давайте зададимся вопросом - а почему это не абстрактный класс?

> Про абстрактные классы прочитать можно [тут](../oop/abstract_class.md).

В целом, на первый взгляд было бы логичным ожидать, что такой класс должен быть абстрактным.
Это кажется логичным даже из названия - `Object`, которое является довольно обобщенным - "объект".

Однако, модификатора `abstract` у `java.lang.Object` нет и мы постараемся ответить на вопрос: почему?

> Все это только мое личное мнение.

Для ответа на этот вопрос давайте разберемся, а какие плюсы принес бы модификатор `asbtract`?

### Пусть java.lang.Object был бы абстрактным

Представим себе ситуацию, когда у `java.lang.Object` существует один или несколько абстрактных методов.
Что это дает?

Пометив какие-то методы `abstract` мы явно потребуем от разработчиков реализации этих методов.

Еще раз взглянем на методы класса `java.lang.Object` и подумаем: насколько упростит жизнь разработчика, то, что хотя бы один из методов будет необходимо каждый раз реализовывать при написании класса.

Методы `wait`, `notify`, `finalize`, `notifyAll` и `getClass` довольно сложны(часть из этих методов являются `native`-методами) и требовать каждый раз от разработчика их реализации - это дополнительные проблемы и большое количество подводных камней, на которые все будут регулярно натыкаться.

Методы `equals`, `hashCode`, `clone` и `toString`, в целом, можно было бы сделать абстрактными, но мое мнение по этому поводу: эти методы относятся к отдельным абстракциям.
Далеко не каждому классу нужно(да и можно) иметь строковое представление, возможности клонирования, сравнения и предоставления `hash`-кода.

На мой взгляд, подобные методы логичнее было бы вынести в собственные интерфейсы, например, `Hashable`, чтобы добавлением интерфейса привнести уже действительно необходимый функционал.

Но объявлять эти методы абстрактными - это уже опять делать шаг в сторону усложнения написания кода, ведь требовать от класса, которому не нужно уметь представлять себя в строковом виде определение `toString` - неразумно и глупо. 
В таком случае разработчик будет каждый раз писать какой-то "фейковый" `toString`, не имеющий ценности и необходимости.

Поэтому, на мой взгляд, оптимальное решение было то, какое выбрали в текущей реализации.

В итоге, как мы сейчас увидели, делать методы класса `java.lang.Object` абстрактными неразумно, так как это только усложнит написание кода и не дает никаких преимуществ.

#### java.lang.Object как абстрактный класс, без абстрактных методов

Теперь предположим, что класс `java.lang.Object` является абстрактным, но не имеет абстрактных методов.

С точки зрения наименований - довольно логично было бы, чтобы такой класс был абстрактным.

Ведь сложно найти что-то, что полностью подходило под описание "объект".
Объект - это всегда что-то абстрактное. Объектами являются и лампа, и машина, и дом.

Поэтому, с точки зрения дизайна языка, было бы правильней чтобы `java.lang.Object` был абстрактным.

Однако, возможность создания некоторого абстрактного объекта может быть полезна, а вот запрет на такое действие не дает никакой выгоды, кроме стилистической, так как это больше вопрос дизайна.

Разберем теперь пользу от возможности создания экземпляра класса `java.lang.Object`.

Экземпляр класса `java.lang.Object` часто используется для `synchronized` операций.
Так как в `Java` можно занять монитор объекта - сделать синхронизацию на нем.

И часто для таких целей пишут что-то в виде:

```java
public class Example {
    private final Object lock = new Object();

    public void doSomething() {
        synchronized (lock) {
            // do possibly dangerous stuff
        }
    }
}
```

Иногда полезно иметь возможность создать некоторый пустой объект, без состояния, для подобных целей.

С другой стороны, для возможности использовать `synchronized` можно было бы сделать специальный объект, например, `java.lang.Lock` или что-то подобное.

Чтобы тип поля явно говорил нам - для чего это поле будет использоваться, ведь когда вы видите поле с типом `Object` - это по началу вводит в ступор, особенно, если название переменной не слишком понятно.

Иногда бывает также удобно иметь возможность создать объект-пустышку, так называемый `Placeholder`, без состояния, например, как реализован `java.util.HashSet`.

Это реализация `java.util.Map`, где ключами являются элементы множества, а значениями будут объекты-пустышки.

И опять же, *можно было бы* ожидать, что для таких целей будет именно так и названный класс, что-то типа `java.lang.Placeholder`, являющийся наследником нашего абстрактного `java.lang.Object`.

> Подробнее про [java.lang.Map](../collections/map/intro.md)

Исходя из вышесказанного можно сделать вывод, что объекты-пустышки иногда бывают полезны и применимы в реальных задачах. И поэтому было бы полезно иметь возможность ими пользоваться, это вполне допустимо и с точки зрения дизайна языка.

Также, возможно, есть еще какие-то применения `java.lang.Object`, например в механизме `Reflection`, в безопасности и так далее.

Поэтому, я считаю, что `java.lang.Object` **может** быть не абстрактным, почему нет?
И лично я не стал бы относить это к минусам дизайна языка.

А вот методы `equals`, `hashCode`, `clone` и `toString`, я считаю, должны быть в отдельных интерфейсах, так, чтобы это поведение я мог *подмешивать* к своему классу тогда, когда мне это было бы надо.

Но что сделано - то сделано.

## Заключение

Каждый класс в `Java` неявно является наследником `java.lang.Object`, благодаря чему каждый класс имеет методы `equals`, `hashCode`, `toString` и т.д.

Помните, что оператор `==` сравнивает объекты по ссылкам, поэтому, если вы хотите сравнивать объекты по внутреннему состоянию, то необходимо переопределить `equals`. Вместе с `equals` обязательно переопределять еще и `hashCode`, так как эти методы тесно связаны друг с другом.

Также хорошим тоном является переопределение `toString`, так как текстовое представление объекта помогает при отладке и печати объекта в консоль или лог-файл.
Следите за тем, чтобы в `toString` не попадала конфиденциальная информация, пароли и т.д. Старайтесь не завязывать логику программы на результат работы `toString`.

Никогда не используйте `finalize`, ввиду непредсказуемости его работы, в частности момента вызова и исполнение метода.

Будьте аккуратнее с методом `clone`, так как при таком клонировании объекта встречается большое количество подводных камней, не вызывается конструктор класса и т.д. Предпочитайте конструктор копирования или статические методы-фабрики.
