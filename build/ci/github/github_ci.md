# Continuous Integration с помощью Github Actions

## Введение 
В [этой](intro.md) статье было рассмотрено, что такое CI и зачем он нужен. Здесь предлагаю рассмотреть пример того, как можно настроить CI с помощью [Github Actions](https://docs.github.com/ru/actions) - платформы непрерывной интеграции и доставки, которая позволяет выстраивать такие процессы, как автоматизация сборки, тестирования и развертывания.

Мы будем использовать Github Actions, чтобы автоматически тестировать наш проект при внесении изменений в удаленный репозиторий. Ожидаемый результат - все тесты пройдут корректно, и задача завершится успешно. Если тесты не пройдут, то мы должны получить подробную информацию о том, какой тест упал и почему. 

## Проект
Во-первых, нужно взять какой-то проект, на котором мы хотим выстроить процессы. Наша цель это запустить юнит-тесты и убедиться, что ничего не валится.
Для примера возьмем [этот](https://github.com/qcha/ci-gradle-example) проект на Java с Gradle.

Это простая библиотека, содержащая абстрактный класс фигуры с методами получения периметра и площади, а также имплементацию этого класса в виде круга. У круга есть поле `radius`, которое должно быть строго положительным. Если это не так, то будет выброшено исключение. 

Напишем юнит-тесты для круга на следующие ситуации:
* Исключение выбрасывается при неположительном радиусе
* Исключение не выбрасывается при положительном радиусе
* Радиус внутри объекта соответствует тому, что мы передали в конструктор
* Подсчет периметра идет по верной формуле
* Подсчет площади идет по верной формуле

Исходный код:
* [Абстрактный класс фигуры](https://github.com/qcha/ci-gradle-example/blob/main/src/main/java/ru/aarexer/figures/Figure.java)
* [Класс круга](https://github.com/qcha/ci-gradle-example/blob/main/src/main/java/ru/aarexer/figures/Circle.java)
* [Класс с тестами](https://github.com/qcha/ci-gradle-example/blob/main/src/test/java/ru/aarexer/figures/CircleTest.java)

## Настройка репозитория
После того, как проект был создан, нам нужно опубликовать его на Github. После публикации, находясь в нашем репозитории, мы увидим меню навигации, на котором красуется кнопка Actions.

![Github Actions](../../images/build/ci/github_actions_1.png)

После нажатия на эту кнопку, перед вами появится следующее меню

![Github Actions 2](../../images/build/ci/github_actions_2.png)

Поскольку наш проект сделан с системой сборки Gradle, выберем `Java with Gradle`, нажав Configure. После этого мы увидим окно редактирования файла с расширением `.yml`. В нем мы описываем необходимые действия, а также когда эти действия должны происходить.

По умолчанию, пайплайн называется `Java CI with Gradle` (строка 8). Он запускается автоматически, когда какой-то коммит попадает в основную ветку или открывается пулл-реквест на основную ветку (строки 10-14).

Далее описываются действия и где они выполняются (строка 14). Github предоставляет пользователям бесплатные раннеры, в этом шаблоне указывается `ubuntu-latest` (строки 15-16). Это значит, что задача будет выполнена на раннере гитхаба на операционной системе Linux Ubuntu последней версии. 

После этого идут шаги, которые мы хотим выполнить. Во-первых, нам нужно установить JDK. По умолчанию указывается версия 11 и дистрибутив Temurin. После этого запускается задача build, выполняемая Gradle, которая производит полную сборку проекта.

![Github Actions 3](../../images/build/ci/github_actions_3.png)

Немного поменяем то, что мы будем делать. Для начала, пусть данные действия выполняются только при коммите в основную ветку. Также, будем использовать JDK версии 17, в качестве дистрибутива возьмем Liberica. И, наконец-таки, мы будем не полностью собирать проект, а исполнять юнит-тесты, поменяем аргумент с `build` на `test`. 

При этом, нужно понимать, что для исполнения юнит-тестов в Gradle выполняются следующие задачи:
1) `compileJava`
2) `processResources`
3) `classes`
4) `compileTestJava`
5) `processTestResources`
6) `testClasses`
7) `test`

Если вы желаете изменить то, что происходит в результате тестирования, то нужно описать собственную задачу в Gradle.

![Github Actions 4](../../images/build/ci/github_actions_4.png)

Подробнее про .yml файл, который используется для описания выполняемых задач:
* `name` - указывает название для задачи
* `on` - указывает, когда данная задача должна выполняться
    * `push` - указывает, что задача будет выполняться при пуше в определенную ветку
      * `branches` - указывает, при пуше в какие ветки должна выполнится задача

    При этом, также можно указать, что задача должна выполняться автоматически при открытии пулл реквеста (параметр `pull-request`, у которого также можно указать ветки), или добавить возможность запускать задачу руками `[workflow_dispatch]`

* `jobs` - указывает, что начинается блок с задачами
    * `task_name` - название задачи внутри блока задач (любое)
        * `runs-on` - указывает, на какой системе будет выполнена задача. Github предоставляет бесплатные раннеры `ubuntu-latest`, `windows-latest`, `macos-latest`. Также, возможно использовать свою собственную машину для выполнения автоматических задач (`self-hosted`). Подробнее о выполнении задач на собственных раннерах [здесь](https://docs.github.com/ru/actions/hosting-your-own-runners/managing-self-hosted-runners/adding-self-hosted-runners).
        * `steps` - указывает, что далее идет секция с непосредственными шагами, которые исполняются последовательно при выполнении данной задачи.
            * `name` - указывает, какое имя будет у этого шага
            * `uses` - указывает, какой существующий в облаке action нужно исполнить. Action - упорядоченный набор действий, который упрощает и сокращает описание задач в .yml формате. Подробнее про action [тут](actions.md).
            * `with` - открывает блок, в котором указываются специальные аргументы для выбранного action (у каждого action свой список параметров). Обычно, это аргументы командной строки или переменные окружения. Например, в случае с шагом `Test with Gradle` мы исполняем gradle с аргументом `test`. По сути, это также как написать в терминале `./gradlew test` и получить лог результата. Пример можете видеть ниже.


![Gradle test example](../../images/build/ci/gradle_test_example.png)

В нашем же случае, данная задача будет выполнена в CI воркфлоу. Выглядеть внутри Github Actions это будет примерно так.

![Github Actions 6](../../images/build/ci/github_actions_6.png)

Теперь нажмем кнопку `Commit changes...` и убедимся, что после того как произошел коммит в основную ветку наша задача выполнилась.

![Github Actions 5](../../images/ci/github_actions_5.png)

## Итоги
Настройка CI сегодня доступна каждому. Показанный пример можно совершенствовать. Например, после прохождения всех необходимых проверок создать докер образ приложения и отправить его в Docker Hub, откуда его может получить сервер и автоматически развернуть новую версию приложения.

## Полезные ссылки

1. [Официальная документация Github Actions](https://docs.github.com/ru/actions)
2. [Автоматизация с Github Actions](https://habr.com/ru/articles/586632/)
3. [Проект, использованный в качестве примера](https://github.com/qcha/ci-gradle-example)

