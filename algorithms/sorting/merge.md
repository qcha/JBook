# Merge Sort
## Сортировка слиянием
### Асимптотическая сложность: *O(n * log(n))*

---

## Содержание

* [Принцип и работа алгоритма](#Принцип-и-работа-алгоритма)

* [Асимптотика](#Асимптотика)

* [Пример](#Пример)

* [Реализация](#Реализация)

* [Заключение](#Заключение)

---
### Принцип и работа алгоритма
Принцип сортировки слиянием заключается в таком подходе, как **"разделяй и властвуй"**.

Идея заключается в том, что для полной сортировки списка, надо отсортировать его меньшие части

Алгоритм использует рекурсивный подход для разделения списка на более мелкие части, затем сортирует их и объединяет в отсортированный список. Принцип работы алгоритма можно описать следующим образом:

* **Разделение:** Исходный список делится на две примерно равные части. Это делается рекурсивно до тех пор, пока каждая часть не будет содержать только один элемент или будет пуста.

* **Слияние:** Каждая пара соседних подсписков сливается в один отсортированный список. Слияние происходит путем сравнения элементов из обоих списков и помещения их в правильном порядке в новый список.

* **Рекурсивное объединение:** Шаги разделения и слияния повторяются рекурсивно для каждого уровня списка до тех пор, пока не будет получен полностью отсортированный список.

---

### Асимптотика

Асимптотическая сложность сортировки слиянием складывается из двух компонентов.

1. Для начала нам надо разделить начальный список так, чтобы мы получили списки длинной не больше 1

Для этого мы делим каждый новый список пополам, пока не достигнем длины 1

        0.                n
        1.           n/2     n/2
        2.         n/4 n/4 n/4 n/4
        3.     ..........n/8.........
        ...
        x.               n/n

Цифры слева - это нумерация операций деления, справа длина списков.

Заметим, что на каждом шаге мы делим на 2^(номер_деления). 
То есть, зная, что последнее значение 1 (так как мы делим список до длины 1), найдем x

    n / (2^x) = 1
    n = 2^x
    x = log_2(n)

Таким образом, чтобы достигнуть списков длины 1, нам надо выполнить log_2(n) делений (без учета константы)

2. Помимо деления, нам надо сортировать списки и собирать их в новые

Рассмотрим **максимальные** количества сравнений на каждом этапе слияния

    Длина списка    Количесво слияний    Cравнений при    Всего сравнений
                                         одном слиянии

          1                n/2                2*1                n     
          2                n/4                2*2                n
          4                n/8                2*4                n
          8                n/16               2*8                n
         ...               ...                ...               ...
          n/2               1                2*(n/2)             n


Таким образом, на каждом уровне у нас получается не больше, чем n операций сравнения.

Как мы выяснили ранее, уровней у нас **log(n)**, на каждом не более **n** операций, тогда справедлива оценка
**O(n * log(n))**
    

---

### Пример

Довольно много букв, поэтому давайте рассмотрим алгоритм на примере и перейдем к реализации

    Исходный список: [5, 8, 7, 2, 9, 3, 1, 6]

**Шаг 1**

Разделяем список на две +- равные части

    Часть 1: [5, 8, 7, 2]
    Часть 2: [9, 3, 1, 6]

**Шаг 2**

Проделываем то же самое для получившихся частей, пока не получим списки длинной не больше 1

*two ours later*

    1: [5, 8] 
    2: [7, 2] 
    3: [9, 3]
    4: [1, 6]

    ---------

    1: [5]
    2: [8]
    3: [7]
    4: [2]
    5: [9]
    6: [3]
    7: [1]
    8: [6]

**Шаг 3**

Получили 8 отсортированных списков (т.к. список длиной 1 можно считать отсортированным)

Теперь начинаем попрано объединять подсписки, сортируя элементы при слиянии

    1 merge 2: [5, 8]
    3 merge 4: [2, 7]
    5 merge 6: [3, 9]
    7 merge 8: [1, 6]

Продолжаем процесс слияния

    12 merge 34: [2, 5, 7, 8]
    56 merge 78: [1, 3, 6, 9]

И теперь сливаем два списка в один

    Sorted result: [1, 2, 3, 5, 6, 7, 8, 9]


*Рассмотрим процесс слияния чуть подробнее*

У нас есть два списка

    1-ый: [2, 5, 7, 8]
    2-ой: [1, 3, 6, 9]

Будем поочередно добавлять меньшие элементы в новый список

Мы начинаем сравнивать первые элементы двух списков, и меньший добавляем в новый.
Затем, берем следующий элемент в списке, из которого добавили, и продолжаем сравнение, добавляя в новый список поочередно все элементы.

    Новый список: []
    1-ое сравнение: 2 и 1 -> добавляем 1
    
    Новый список: [1]
    2-ое сравнение: 2 и 3 -> добавляем 2

    Новый список: [1, 2]
    3-ье сравнение: 5 и 3 -> добавляем 3

    Новый список: [1, 2, 3]
    4-ое сравнение: 5 и 6 -> добавляем 5

    Новый список: [1, 2, 3, 5]
    5-ое сравнение: 7 и 6 -> добавляем 6
    
    Новый список: [1, 2, 3, 5, 6]
    6-ое сравнение: 7 и 9 -> добавляем 7

    Новый список: [1, 2, 3, 5, 6, 7]
    7-ое сравнение: 8 и 9 -> добавляем 8

    Новый список: [1, 2, 3, 5, 6, 7, 8]
    Элементы в первом списке закончились, добавляем все элементы из 2-ого

    Добавили 9 из 2-ого списка
    Новый список: [1, 2, 3, 5, 6, 7, 8, 9]

---

### Реализация

```java

public class MergeSort {

    public static void mergeSort(int[] arr) {

        // Если в массиве нет минимум двух элементов, то сортировать нечего
        if (arr.length <= 1) {
            return;
        }

        // Делим массив на два +- равных подмассива
        int mid = arr.length / 2;
        int[] left = new int[mid];
        int[] right = new int[arr.length - mid];

        // Заполнение подмассивов
        System.arraycopy(arr, 0, left, 0, mid);

        System.arraycopy(arr, mid, right, 0, arr.length - mid);

        // Рекурсивная сортировка подмассивов
        mergeSort(left);
        mergeSort(right);

        // Слияние отсортированных подмассивов
        merge(left, right, arr);
    }

    public static void merge(int[] left, int[] right, int[] arr) {
        int leftInd = 0; // индекс для массива left
        int rightInd = 0; // индекс для массива right
        int resultInd = 0; // индекс для результирующего массива

        // Слияние элементов из подмассивов в результирующий массив
        while (leftInd < left.length && rightInd < right.length) {
            if (left[leftInd] <= right[rightInd]) {
                arr[resultInd] = left[leftInd];
                leftInd++;
            } else {
                arr[resultInd] = right[rightInd];
                rightInd++;
            }
            resultInd++;
        }

        // Копирование оставшихся элементов из левого подмассива (если есть)
        while (leftInd < left.length) {
            arr[resultInd] = left[leftInd];
            leftInd++;
            resultInd++;
        }

        // Копирование оставшихся элементов из правого подмассива (если есть)
        while (rightInd < right.length) {
            arr[resultInd] = right[rightInd];
            rightInd++;
            resultInd++;
        }
    }
}

```
---

### Заключение

Сортировка слиянием - 
это эффективный алгоритм сортировки, который может быть применен в различных ситуациях в реальной жизни.
Он используется для упорядочивания данных, когда требуется отсортировать большой объем информации.

* Сортировка слиянием может использоваться для сортировки больших наборов данных в базах данных. Например, когда требуется отсортировать результаты запроса, содержащего миллионы записей.

* Если данные не помещаются в оперативную память компьютера, сортировка слиянием позволяет выполнять сортировку на жестком диске или других внешних носителях данных.