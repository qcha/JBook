# Абстрактный класс

- [Абстрактный класс](#абстрактный-класс)
    - [Введение](#введение)
    - [Объявление](#объявление)
    - [Использование](#использование)
        - [Применение](#применение)
        - [Анонимные классы](#анонимные-классы)
    - [Заключение](#заключение)

## Введение

Как мы уже обсуждали во [введении в ООП](./intro.md), класс - это совокупность `поведения` и `состояния`.

Состояние - это то, какую информацию, какие данные хранит этот класс.

Например, рассмотрим класс `Person`:

```java
class Person {
    private int age;
    private String name;

    public void greeting() {
        System.out.println("Hello!");
    }
}
```

Он содержит переменные, которые будут хранить возраст и имя.
При этом, у каждого созданного объекта этого класса будет свой возраст и имя, они и будут состоянием объекта.

Поведение же это то, как взаимодействовать с объектом.
За публичное поведение объекта (то как с ним взаимодействовать) в `Java` отвечает понятие [интерфейса](./interface.md).

В нашем случае - это метод `public void greeting`.

Наш класс `Person` - это полностью определнный, завершенныый класс.

Что значит полностью определенный класс или что класс завершен?

Назовем класс полностью определенным, если его поведение (интерфейс) реализовано, т.е мы точно знаем **что** умеет делать объект класса и **как** он это делает, такой класс **полностью** реализует свой интерфейс, он **конкретен**.

Но что если мы хотим описать класс, напрмиер, только с частично определенным поведением? Т.е. мы можем ответить на вопрос **что** будет делать класс, но еще не определили **как именно** он и его потомки будут это делать - создать абстракцию.

Возьмем любимый пример всех учебников по программированию для начинающих: класс `Figure`.

Фигура - это нечто асбтрактное, это может быть и квадрат, и круг, и прямоугольник. Когда говорят фигура мы не можем представить ничего конкретного.

Однако у фигур есть площадь и периметр!

Мы могли бы определить методы, считающие площадь и периметр фигуры, но реализация этих методов будет у каждого класса-наследника своя.
Т.е. мы понимаем **что** должны уметь фигуры (считать площадь и периметр), но не понимаем **как**, так как реализация будет разная у фигур.

Это значит, что наш класс `Figure` будет незаконченным.

Для подобных случаев в `Java` можно сделать класс `абстрактным`.

## Объявление

Для того, чтобы объявить класс абстрактным существует ключевое слово `abstract`.

```java
public abstract class Figure {
    // some code
}
```

Как было сказано выше: абстрактность относится еще и к тому, что `поведение` класса определено не до конца.

Из этого можно сделать вывод, что методы класса, поведение которых мы в данном классе определить/реализовать не можем, также помечаются как абстрактные:

```java
public abstract class Figure {
    // Fields
    // ...

    abstract int area();
    abstract int perimeter();

    // some code
    // ...
}
```

Если класс содержит **хотя бы один** абстрактный метод, то он обязан быть абстрактным классом.

---

**Вопрос**:

Может ли класс быть абстрактным, при этом **не имея** абстрактных методов? Другими словами: валиден ли следующий код?

```java
public abstract class Figure {
    public int area() {
        return 14;
    }
}
```

**Ответ**:

Да, класс может быть абстрактным, при этом не имея абстрактных методов.

Такие классы могут понадобиться вам, чтобы выстраивать более гибкую цепочку иерархий классов. К тому же, никто не запрещает вам при необходимости переопределить какие-то методы такого класса.

Ответ: валиден.

---

Как объявить абстрактный класс разобрались, теперь посмотрим как c этим работать.

## Использование

Основным отличием абстрактных классов от обычных в использовании является то, что запрещается создавать экземпляр (или instance, инстанс, объект класса) абстрактного класса.

Другими словами, вы не можете написать пример ниже с абстрактным классом `Figure`:

```java
public abstract class Figure {
    // some code
}

public class Main {
    public static void main(String[] args) {
        Figure p = new Figure(); // Compile Error
    }
}
```

Запрет этот наложен именно из-за признака незавершенности класса.

Экземпляр класса должен олицетворять нечто законченное, то, с чем можно работать и понятно как работать. У абстрактных классов такое гарантировать нельзя, отсюда и запрет.

Если задуматься, то в реальном мире происходит нечто похожее: мы оперируем только завершенными объектами, но можем ссылаться на какие-то абстрактные вещи.
Например, вы можете сказать: "Я купил лампу", но без деталей вашей новой покупки каждый человек представит себе "свою" лампу, ведь вы описали нечто абстрактное.

Также и с нашим примером фигуры:

```java
public class Main {
    public static void main(String[] args) {
        Figure p = new Circle();
        Figure p = new Rhombus();
    }
}
```

При этом абстрактный класс **может** иметь конструктор.

```java
public abstract class Figure {
    protected int height;
    protected String width;

    public Figure(int height, String width) {
        this.height = height;
        this.width = width;
    }
}
```

---

**Вопрос**:

Какой смысл в конструкторе, если создать экземпляр абстрактного класса все равно нельзя?

**Ответ**:

Надо помнить, что конструктор супер-класса (родительского) явно участвует в создании объекта класса-наследника и конструктор абстрактного класса - не исключение.
Например, его можно использовать для задания начальных значений общих переменных, объявленных в абстрактном классе.

Грубо говоря, абстрактный класс - это как фундамент, на котором строится уже остальное. Конструктор абстрактного класса как раз и создает этот фундамент.

---

**Вопрос**:

Может ли абстрактный класс иметь абстрактный конструктор?

**Ответ**:

Нет, не может.
Ответ на этот вопрос логичен, если задуматься какую роль выполняет конструктор - создание объекта.

---

**Вопрос**:

Может ли абстрактный класс иметь абстрактный статический метод?

**Ответ**:

Снова нет, что, на мой взгляд, довольно логично.

При этом абстрактный класс может иметь определенный статический метод, хоть это и не совсем желательно, так как статические методы плохо укладываются в `ООП`.

Более того, абстрактный класс может даже содержать метод `main` - так как это просто еще один статический метод.

---

**Вопрос**:

Может ли абстрактный класс быть объявлен с модификатором `final`? Т.е. быть финальным?

**Ответ**:

Нет, иначе теряется весь смысл абстрактного класса, о чем вам сообщит компилятор, выдав ошибку компиляции.

---

### Применение

Когда стоит применять абстрактные классы?

Как вы наверняка поняли, абстрактные классы в основном предназначены для использования в [наследовании](./inheritance.md). Т.е. стоит создавать абстрактный класс тогда, когда вам нужен еще один слой абстракции в который вы готовы выделить какие-то поля или методы.

Чтобы отойти от довольно распространенных Figure, Animal и так далее, давайте посмотрим как это применяется в `JDK` на примере списков.

В `Java` у нас есть интерфейс коллекций: `java.util.Collection` и абстракции `java.util.AbstractCollection`, `java.util.AbstractList`.
Ну а конечные реализации `java.util.ArrayList`, `java.util.LinkedList` и т.д. завершают абстракции.

Например, `java.util.AbstractCollection` определяют метод `isEmpty`:

```java
 public boolean isEmpty() {
        return size() == 0;
    }
```

Но не является завершенным, так как еще непонятно что будет 'под капотом' нашего списка. В промежуточном слое, в `java.util.AbstractList`, мы **уже** знаем как определить некоторые методы, например, `indexOf`, но при этом вы еще не знаете как делать `get(int index)`, так как реализация `get` явно зависит от конкретной реализации.

Ну а уже `java.util.ArrayList` являются конечными реализациями.

Однако абстрактные классы не всегда хорошее решение и [здесь](./abstract_vs_interface.md) более подробно обсуждается их применение и что лучше: абстрактный класс или интерфейс.

### Анонимные классы

Важно отметить, что завершенность класса может быть и с помощью создания анонимного класса, у которого будут определены абстрактные методы.

 ```java
public abstract class Figure {
     abstract void draw();
}

public class Main {
    public static void main(String[] args) {
        Figure p = new Figure() {
            public void draw() {
                System.out.println("Draw something anonymous");
            }
        }
    }
}
 ```

Здесь объявлен абстрактный класс `Figure` и в методе `main` мы создали анонимный класс, реализующий абстрактные методы `Figure`.

Таким образом мы **завершили** абстрактный класс, но не дали имени этому завершенному классу, отсюда и название - `анонимный` класс.

## Заключение

Абстрактные классы помогают описывать промежуточные состояния, выстраивать иерархии классов и добавлять новые слои абстракции.

Стоит отметить, что `java.lang.Object` не является абстрактным классом, хоть иногда и кажется, что сделать это было бы логично.
Почему так сделано, я рассуждаю [здесь](../object/intro.md).

Абстрактные классы могут реализовывать интерфейсы, при этом, так как абстрактный класс может содержать абстрактные методы, допускается реализовывать не все методы у реализуемых интерфейсов.

Также, класс может не содержать абстрактных методов и при этом быть абстрактным.
Но класс, содержащий хотя бы один абстрактный метод **обязан** должен быть абстрактным классом.

Абстрактные классы тесно связаны с понятием [интерфейса](./interface.md), поэтому [здесь](./abstract_vs_interface.md) мы разберем отличия абстрактного класса от интерфейса, а также что и когда использовать.
