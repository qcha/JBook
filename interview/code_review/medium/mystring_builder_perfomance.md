# MyStringBuilder

## Условие

Дан следующий класс:

```java
public class MyStringBuilder {
    private final List<Character> buffer;
 
    public MyStringBuilder() {
        this.buffer = new ArrayList<>();
    }
 
    public void addToEnd(String s) {
        List<Character> list = new ArrayList<>();
        for (char c : s.toCharArray()) {
            list.add(c);
        }

        buffer.addAll(list);
    }
 
    public void addToStart(String s) {
        List<Character> list = new ArrayList<>();
        for (char c : s.toCharArray()) {
            list.add(c);
        }

        buffer.addAll(0, list);
    }
     
    public Character get(int index) {
        return buffer.get(index);
    }
 
    @Override
    public String toString() {
        var result = "";
        for (var chr : buffer) {
            result += chr;
        }

        return result;
    }
 
    public int distinctCharsCount() {
        var cache = new ArrayList<Character>();
        
        for (var c : buffer) {
            if (cache.indexOf(c) == -1)
                cache.add(c);
        }
 
        return cache.size();
    }
}
```

Требуется:

* Оценить каждый метод по производительности.
* Предложить варианты изменения кода для повышения производительности методов (после оценки).

## Решение

### Методы

* addToEnd

    O(N), где N - это длина строки s.

    Заметим, что внутри `ArrayList` лежит массив, который может расширяться, если недостаточно места для новых элементов.

* addToStart

    O(N + M), где N - длина строки s, а M - размер самого списка.

    При добавлении символов в начало списка нужно сдвинуть все ранее добавленные символы вправо, при необходимости надо также расширить массив внутри buffer.

    Сдвиг происходит с помощью метода `System.arrayCopy`.

* get

    O(1)

    Обращение по индексу в массиве.

* toString

    O(N^2)

    Строки в `Java` иммутабельны, а значит, на каждой итерации цикла происходит создание новой строки result.
    Внутри строки массив `char`, следовательно, на каждую конкатенацию строк будет копирование массивов (исходной и добавляемой).

* distinctCharsCount

    O(N * M), где N - это длина массива, а M - это алфавит символов строки (т.е. количество различных символов).

    Метод `indexOf` будет искать символ полным проходом по `differentCharacters`, но в нем могут быть только уникальные значения (по сути - алфавит строки), отсюда N - это проход по `buffer`, а M - это проход по `differentCharacters`.

### Улучшения

При продумывании улучшений первое что надо сделать, это спросить у интервьюера статистику использования методов.
Зачастую от этого можно выстраивать стратегию улучшений. Например, если скажут, что метод get практически никогда не используется, можно выбрать иную структуру данных для `buffer`, которая может не обеспечивать O(1) работу `get`, но существенно улучшит другие методы.

Хранить в списке `Character` затратно, т.к. это объект, поэтому эффективнее использовать массив char, который перевыделять самостоятельно. Воссоздать логику, похожую на `java.util.ArrayList`, при хранении элементов и расширении массива под капотом.

В таком случае добавление в начало и в конец можно будет делать явно через `System.arrayCopy`, предварительно увеличив размер буфера на нужное количество символов. Из этого же будет следовать то, что мы избавимся от аллокации list-а.

В качестве косметических улучшений можно заметить, что в методах `addToEnd` и `addToStart` код дублируется.

Можно не переходить к массивам и оптимизировать работу класса, заменив `java.util.ArrayList` для `buffer` на другую структуру данных (например, на `java.util.ArrayDeque`).

Заметим, что уникальность элементов можно обеспечить используя множества. Тогда в методе `distinctCharsCount` можно заменить `cache` на `java.util.HashSet`, в таком случае сложность метода снизится до O(N).

В методе `toString` сразу работаем с массивами, конвертируя список `buffer` в массив, аллоцировав нужный размер для результирующей строки и скопировав массив `buffer` в аллоцированный. После создаем строку от массива (в который мы совершили копирование). Сложность метода снизится до O(N).
