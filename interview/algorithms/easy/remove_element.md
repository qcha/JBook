# Remove Element

Задача с [LeetCode](https://leetcode.com/problems/remove-element/description/).

## Условие

Дан массив целых чисел `nums` и целое число `val`.

Необходимо удалить все вхождения `val` в массиве `nums` как [in-place](https://en.wikipedia.org/wiki/In-place_algorithm). Порядок элементов может быть изменён. Затем вернуть количество элементов в массиве nums, которые не равны val.

Считая, что количество элементов в массиве `nums`, которые не равны `val`, равно `k`, надо:

* Изменить массив `nums` так, чтобы первые `k` элементов `nums` содержали элементы, не равные `val`. Остальные элементы массива `nums`, как и размер массива, не важны
* Вернуть k

### Примеры

```java
Example 1:

Input: nums = [3,2,2,3], val = 3
Output: 2, nums = [2,2,_,_]

Example 2:

Input: nums = [0,1,2,2,3,0,4,2], val = 2
Output: 5, nums = [0,1,4,0,3,_,_,_]

```

## Решение

В задаче нам важно перенести все не равные val значения в начало массива, при этом порядок не важен.

Пусть j - это указатель, который всегда указывает на крайнее левое место, где находится один из встреченных val.

```text
 i
 |
[3][2][2][3]
 |
 j
```

Заведем отдельный указатель, для итерации по массиву, и начнем итерироваться по массиву до тех пор, пока не встретим элемент не равный val:

```text
    i
    |
[3][2][2][3]
 |
 j
```

Теперь перенесем элемент из i-й позиции в j-ую, после чего сделаем инкремент j:

```text
    i
    |
[2][2][2][3]
    |
    j
```

Мы 'перезатерли' нашу 3-ку, но это и не важно по условию задачи, теперь j снова указывает на место, куда можно перенести следующий не равный val элемент. При этом мы снова можем затереть значение, потому что место, куда указывает j - это по сути свободное место, значение там нам не важно.

Инкрементим i как обычно, завершая шаг итерации:

```text
       i
       |
[2][2][2][3]
    |
    j
```

Снова встречаем элемент не равный val и переносим на j-ое место, инкрементим j и i:

```text
          i
          |
[2][2][2][3]
       |
       j
```

Далее встречаем уже элемент, равный val и игнориуем его, просто инкрементим i дальше.

Массив подходит к концу и все элементы, не равные val оказываются в позициях от 0 до j (не включительно).

В коде это выглядит как:

```java
    public static int removeElement(int[] nums, int val) {
        if (nums.length == 0) {
            return 0;
        }

        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != val) {
                nums[j] = nums[i];
                j++;
            }
        }

        return j;
    }
```

### Асимптотика решения

Время: O(N)

Память: O(1)
