# Название
Середина односвязного списка
## Введение
На собеседованиях на backend-разработчика уровня junior/middle часто встречаются довольно простые задачи на алгоритмы, которые нужно уметь решать быстро, четко и корректно, чтобы повысить свои шансы на успех. Одна из таких задач - [задача нахождения середины односвязного списка](https://leetcode.com/problems/middle-of-the-linked-list/description/).

Если вы забыли или не знаете, что такое односвязный список, то можете посмотреть [статью](https://github.com/qcha/JBook/blob/master/jcore/collections/list/linked_list.md). Вкратце, основная особенность в том, что каждый элемент знает лишь своё значение и хранит "ссылку" на следующий элемент списка. Соответственно, мы не можем обратиться к любому элементу по индексу за О(1), так как чтобы найти n-ый элемент списка, нужно проитерироваться по всему списку от головы до n-ого элемента (каждый раз переходя от текущего на следующий элемент).
## Основная часть
### Постановка задачи
Наша задача найти срединный элемент односвязного списка (естественно, итерироваться по списку можно не более 1 раза). 

Срединным будем считать элемент с индексом `n div 2` (индекс считается с 0), где `n` - длина списка. *Это уточнение однозначно определит, какой элемент считается срединным, если в списке чётное количество элементов.*

**Как думать**: в любой алгоритмической задаче на связные списки нужно как-то корректно перемещаться по списку, запоминать указатели на "важные" элементы, правильно переприсваивать их и учитывать то, что список обычно не бесконечный. Раз мы никогда не обладаем "полной информацией" о списке, не можем получить ее за О(1) и не умеем обращаться по индексу; значит нужно иметь указатель на средний элемент списка всегда, на любой итерации алгоритма. Тогда мы в любой момент сможем ответить на вопрос: "какой срединный элемент в той части списка, по которой мы проитерировались к данной итерации?".

### Решение
Изначально, всё что у нас есть - это указатель на первый элемент списка (голова).

Все это наталкивает на довольно простой и часто встречающийся алгоритм в easy-задачах на массивы и списки под общим названием "Два указателя - two pointers".

Следовательно, перед каждой итерацией один наш указатель (`curr`) всегда указывает на следующий "обозреваемый" элемент, а второй (`mid`) - на срединный элемент части списка от его начала до следующего элемента не включительно. Изначально: следующий элемент - это голова списка, серединный элемент - также голова списка.

Остается лишь корректно сдвигать оба указателя в каждой итерации. Для этого можно завести булевый флаг (`isShiftMiddle`), значение которого мы будем менять на противоположное в конце абсолютно каждой итерации. Текущий указатель мы будем сдвигать тоже на каждой итерации, а вот указатель на текущую середину - только когда значение флага = true.

Первоначальное значение флага - false, так как после первой итерации указатель на срединный элемент сдвинуться не должен.

Тогда псевдо-код решения будет выглядеть так:
```
curr = head
mid = head
isShiftMiddle = false
while (curr != null) {
    curr = curr.next
    if (isShiftMiddle) mid = mid.next
    isShiftMiddle = !isShiftMiddle
}

return mid
```
