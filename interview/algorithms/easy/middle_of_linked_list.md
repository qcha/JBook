# Середина односвязного списка

На собеседованиях на backend-разработчика уровня junior/middle часто встречаются довольно простые задачи на алгоритмы, которые нужно уметь решать быстро, четко и корректно, чтобы повысить свои шансы на успех. Одна из таких задач - [задача нахождения середины односвязного списка](https://leetcode.com/problems/middle-of-the-linked-list/description/).

Если вы забыли или не знаете, что такое односвязный список, то можете посмотреть [статью](https://github.com/qcha/JBook/blob/master/jcore/collections/list/linked_list.md). Вкратце, основная особенность в том, что каждый элемент знает лишь своё значение и хранит "ссылку" на следующий элемент списка. Соответственно, мы не можем обратиться к любому элементу по индексу за О(1), так как чтобы найти n-ый элемент списка, нужно проитерироваться по всему списку от головы до n-ого элемента (каждый раз переходя от текущего на следующий элемент).

## Условие

Наша задача найти срединный элемент односвязного списка (естественно, итерироваться по списку можно не более 1 раза). 

Срединным будем считать элемент с индексом `n / 2` (индекс считается с 0), где `n` - длина списка. *Это уточнение однозначно определит, какой элемент считается срединным, если в списке чётное количество элементов.*

Изначально, всё что у нас есть - это указатель на первый элемент списка (голова).

### Примеры

```
Входной список: 1 -> 7 -> 3 -> 2 -> 5.
Ожидаемый ответ: 3.
```

```
Входной список: 4 -> 5 -> 6 -> 7.
Ожидаемый ответ: 6.
```

```
Входной список: null.
Ожидаемый ответ: null.
```

## Решение

**Как думать**: в любой алгоритмической задаче на связные списки нужно как-то корректно перемещаться по списку, запоминать указатели на "важные" элементы, правильно переприсваивать их и учитывать то, что список обычно не бесконечный. Раз мы никогда не обладаем "полной информацией" о списке, не можем получить ее за О(1) и не умеем обращаться по индексу; значит нужно иметь указатель на средний элемент списка всегда, на любой итерации алгоритма. Тогда мы в любой момент сможем ответить на вопрос: "какой срединный элемент в той части списка, по которой мы проитерировались к данной итерации?".

Все это наталкивает на довольно простой и часто встречающийся алгоритм в easy-задачах на массивы и списки под общим названием "Два указателя - two pointers".

Это даже скорее не конкретный алгоритм, а идея решения, которая заключается в том, что в каждый момент времени в программе есть два указателя на элементы одного списка (или же просто два индекса, если мы говорим про классический массив). Причем указатели именно на те элементы, которые нам важны с точки зрения алгоритма решения задачи.

Следовательно, перед каждой итерацией один наш указатель (`curr`) всегда указывает на следующий "обозреваемый" элемент, а второй (`mid`) - на срединный элемент части списка от его начала до следующего элемента не включительно. Изначально: следующий элемент - это голова списка, серединный элемент - также голова списка.

Остается лишь корректно сдвигать оба указателя в каждой итерации. Для этого можно завести булевый флаг (`isMoveMid`), который обозначает, нужно ли в текущей итерации по списку сдвигать указатель на срединный элемент. То есть указатель на середину списка должен сдвигаться на каждой второй итерации, в то время как указатель на текущий элемент очевидно сдвигается на каждой итерации.
Чтобы добиться сдвига списка только на каждой второй итерации, значение булевого флага мы будем менять на противоположное в конце абсолютно каждой итерации. Текущий указатель мы будем сдвигать тоже на каждой итерации, а вот указатель на текущую середину - только когда значение флага = true.

Первоначальное значение флага - false, так как после первой итерации указатель на срединный элемент сдвинуться не должен.

Тогда код решения на Java будет выглядеть так:
```
public static ListNode middleNode(ListNode head) {
    ListNode curr = head;
    ListNode mid = head;
    boolean isMoveMid = false;

    while (curr != null) {
        curr = curr.next;

        if (isMoveMid) {
            mid = mid.next;
        }

        isMoveMid = !isMoveMid;
    }

    return mid;
}
```

### Асимптотика алгоритма

Асимптотическая сложность по времени: `О(n)`, где n - количество элементов в связном списке, так как чтобы найти решение, необходимо проитерироваться по всему списку полностью ровно один раз (то есть n итераций).

Сложность алгоритма по памяти: `O(1)`, то есть константа, так как, независимо от длины списка n, расходуется память на 2 дополнительных указателя на ListNode и одно boolean-значение.
