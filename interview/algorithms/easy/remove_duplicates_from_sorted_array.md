# Remove Duplicates from Sorted Array

Задача с [LeetCode](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/).

## Условие

Дан массив целых чисел `nums`, отсортированный по неубывающему значению.

Необходимо удалить все дубликаты в массиве `nums` как [in-place](https://en.wikipedia.org/wiki/In-place_algorithm). Относительный порядок элементов должен остаться прежним. Затем вернуть количество элементов в массиве `nums`.

Предположим, что количество уникальных элементов массива `nums` равно `k`. Необходимо:

* Изменить массив `nums` так, чтобы первые `k` элементов массива содержали уникальные элементы в том порядке, в котором они изначально присутствовали в массиве. Остальные элементы массива, как и размер, не важны.

* Вернуть k.

### Примеры

```java
Example 1:

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]

Example 2:

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]

```

## Решение

Подобные задачи подразумевают, что мы будем оперировать как будто двумя массивами: один оригинальный и второй 'уникальных элементов'. Так как в условии явно сказано, что надо менять in-place, то физически массив будет один.

Для итерации мы заведем два указателя: один для итерации по оригинальному массиву, а второй для отслеживания места, где у нас уникальные элементы. Для уникальных элементов будем использовать `j`.

В самом начале это:

```text
 i
 |
[0][0][1][1][2]
 |
 j
```

Начнем итерироваться по массиву до тех пор, пока не встретим элемент не равный тому, на который указывает `j`:

```text
       i
       |
[0][0][1][1][2]
 |
 j
```

Так как нам необходимо сохранить порядок элементов, но без дубликатов, то нам достаточно просто сдвинуть `j` на единицу и поменять местами i-й и j-й элементы:

```text
       i
       |
[0][1][1][1][2]
    |
    j
```

Мы 'перезатерли' наш 0, но это и не важно по условию задачи, теперь j снова указывает на место, где у нас заканчиваются уникальные элементы.

Инкрементим i как обычно, пока снова не встретим элемент, уже не равный 1:

```text
             i
             |
[0][1][1][1][2]
    |
    j
```

Снова сдвигаем j и меняем местами элементы:

```text
             i
             |
[0][1][2][1][2]
       |
       j
```

Массив подходит к концу и все уникальные элементы у нас расположены от начала и до j-й позиции включительно.

Теперь осталось вернуть `k` - которое по сути является длиной массива уникальных чисел.

В коде это выглядит как:

```java
    public static int removeDuplicates(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }

        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != nums[j]) {
                j++;
                nums[j] = nums[i];
            }
        }

        return j + 1;
    }
```

### Асимптотика решения

Время: O(N)

Память: O(1)
