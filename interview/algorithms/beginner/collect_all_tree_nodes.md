# Обход дерева и сбор всех нод в коллекцию

## Условие

Дано дерево, каждая нода которого это:

```java
class TreeNode<T> {
    T value;
    List<TreeNode<T>> nodes;
}
```

Требуется написать метод, принимающий на вход корень дерева, и выдающий коллекцию всех значений нод дерева (порядок не важен).

## Решение

### Рекурсивное решение с помощью обхода в глубину

Будем считать, что терминальной нодой считается нода, внутренний список нод которой пуст (но у ноды есть value).
Создадим вспомогательный метод `fillListWithNodes`, который будет производить рекурсивное заполнение списка обходом в глубину.

Основным методом будет `getAllNodes`, который принимает корень дерева, создает пустой список, который мы будем заполнять значениями нод, а затем вызывает вспомогательный метод, который производит рекурсивное заполнение.

```java
public static <E> void fillListWithNodes(TreeNode<E> node, List<E> nodeList) {
    // Добавляем значение текущей ноды в список
    nodeList.add(node.value);    
    
    // Для всех детей текущей ноды запускаем рекурсию
    for (var childrenNode : node.nodes) {
        fillListWithNodes(childrenNode, nodeList);
    }
}

public static <E> List<E> getAllNodes(TreeNode<E> node) {
    var nodeList = new ArrayList<E>();
    fillListWithNodes(node, nodeList);

    return nodeList;
}
```

Минусы:

* Рекурсивные решения часто проигрывают по памяти и эффективности итеративным

### Итеративное решение с помощью обхода в глубину

Условие все тоже, терминальной нодой считается нода, внутренний список нод которой пуст (при этом, она содержит значение).\
В этот раз обойдемся одним методом `getAllNodes`, который создает список значений, а затем производит заполнение значениями итеративно.

```java
public static <E> List<E> getAllNodes(TreeNode<E> node) {
    var nodeList = new ArrayList<E>();

    Queue<TreeNode<E>> queue = new ArrayDeque<>();
    queue.add(node);

    while (!queue.isEmpty()) {
        // Вытаскиваем первый элемент из очереди
        var element = queue.poll();

        // Добавляем значение в список
        nodeList.add(element.value);

        // Добавляем всех детей текущей ноды в очередь
        queue.addAll(element.nodes);
    }

    return nodeList;
}
```

Подобные задачи проверяют, способны ли вы отойти от шаблонного бинарного дерева и чуть-чуть поменять решение на случай, когда дочерних нод переменное количество.
