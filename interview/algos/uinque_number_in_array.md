# Уникальное число в массиве

## Условие

Дан массив целых чисел, в котором каждое число встречается два раза и лишь одно число уникально.
Найдите это число.

### Примеры

```java
[-1, 2, -1, 5, 5, 2, 8]

Ответ: 8
```

```java
[2, 4, 5, 3, 5, 4]

Ответ: 3
```

## Решение

### Решение с сортировкой

Отсортируем массив и тогда пары чисел будут рядом друг с другом.
После этого простым перебором найдем первое число, у которого нет пары, стоящей рядом.

```java
    public static int uniqueNum(int[] arr) {
        Arrays.sort(arr);

        for (int i = 0; i < arr.length; i++) {
            if (i == arr.length - 1) {
                return arr[i];
            }

            if (arr[i] != arr[i + 1]) {
                return arr[i];
            }

            i++;
        }

        throw new IllegalStateException("No answer");
    }
```

Сортировка работает за O(N * log(N)), что следует из документации по `Arrays.sort`.
Затраты по памяти константа, так как мы не выделяем новой памяти.

Время работы: O(N * log(N))

Память: O(1)

### Решение с множеством

Создадим кеш-множество и проходя по массиву будем удалять те элементы, которые уже есть в кеше.
Если же элемента в кеше нет, то добавляем этот элемент в кеш.

В таком случае, в конце прохода по массиву у нас останется кеш с одним элементом - искомым.

```java
    public static int uniqueNum2(int[] arr) {
        var cache = new HashSet<Integer>();

        for (int elem : arr) {
            if (cache.contains(elem)) {
                cache.remove(elem);
            } else {
                cache.add(elem);
            }
        }

        return cache.iterator().next();
    }
```

Линейное время, так как осуществляется проход по массиву.
Линейные затраты по памяти, так как кеш в худшем случае (когда искомый элемент в конце массива) разрастется до размеров массива.

Время работы: O(N)

Память: O(N)

### Решение с XOR

Рассмотрим массив чисел: [1, 2, 2].

Нарисуем битовое представление каждого, после чего применим к каждому биту оператор `xor`:

| 1  | 2  | 2  | Результат XOR  |
|----|----|----|----------------|
| 0  | 1  | 1  |       0        |
| 1  | 0  | 0  |       1        |

Результат: 1. Это искомое число.

Почему мы получили искомое число? Так как в массиве все числа имеют пару, кроме одного, то у каждого бита также будет пара - кроме одного.
Отсюда и результат!

```java
    public static int uniqueNum3(int[] arr) {
        return Arrays.stream(arr).reduce((left, right) -> left ^ right).getAsInt();
    }
```

Время работы: O(N)

Память: O(1)
