# Объединить два отсортированных массива

## Условие

Даны два отсортированных по неубыванию массива целых чисел. Требуется вернуть новый массив, который содержит все числа из этих двух массивов, отсортированные в порядке неубывания.

## Решение

По сути, от нас требуют реализовать вспомогательную функцию `merge`, которая используется в сортировке слиянием (merge sort).

Нужно создать результирующий массив, размер которого будет суммой размеров двух передаваемых в метод массивов.

Также, нам нужно три индекса - индекс для движения по первому массиву, для движения по второму массиву, а также для движения по результирующему массиву.

Первый цикл будет идти, пока мы не рассмотрим элементы хотя бы в одном из массивов.

Последние два цикла взаимоисключающие. В них мы попадем в том случае, если в одном из массивов закончились элементы, а в другом нет.

```java
public class Solution {
    public static int[] merge(int[] first, int[] second) {
        int[] array = new int[first.length + second.length];

        // Создадим индексы для движения по первому, второму и результирующему массивам соответсвенно
        int firstIndex = 0;
        int secondIndex = 0;
        int index = 0;

        // Идем по обоим массивам, пока в одном из них не кончатся элементы
        while (firstIndex < first.length && secondIndex < second.length) {
            // Если текущий элемент в первом массиве меньше текущего элемента во втором массиве
            // То на текущее место в результирующем массиве нужно поставить элемент из первого массива
            // и сдвинуться на один индекс вправо в первом и результирующем массиве

            // Иначе, нужно на текущее место в результирующем массиве поставить элемент из второго массива
            // и сдвинуться на один индекс вправо во втором и результирующем массиве
            if (first[firstIndex] < second[secondIndex]) {
                array[index++] = first[firstIndex++];
            } else {
                array[index++] = second[secondIndex++];
            }
        }
        
        // Попадание в этот цикл значит, что мы просмотрели все элементы из второго массива, 
        // значит можно последовательно записать оставшиеся элементы из первого массива
        while (firstIndex < first.length) {
            array[index++] = first[firstIndex++];
        }

        // Попадание в этот цикл значит, что мы просмотрели все элементы из первого массива, 
        // значит можно последовательно записать оставшиеся элементы из второго массива
        while (secondIndex < second.length) {
            array[index++] = second[secondIndex++];
        }

        return array;
    }
}
```

Время работы: O(N + M), где N - размер первого массива, M - размер второго массива

Память: O(N + M), где N - размер первого массива, M - размер второго массива
